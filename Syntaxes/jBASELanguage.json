{
   "Language": {
      "Type": "jBASE PickBASIC",
      "Keywords": [
         {
            "key": "$Include",
            "icon": 14,
            "index": 1,
            "documentation": "The $INCLUDE or $INSERT directive inserts the program/code snippet specified into the current source code.\r\nIf the optional filename is specified the code is read from that file.",
            "detail": "$INCLUDE programname\r\n$INCLUDE filename programname\r\n$INSERT programname\r\n$INSERT filename programname"
         },
         {
            "key": "@Am",
            "icon": 21,
            "index": 2,
            "documentation": "Inserts an attribute mark CHAR(254).",
            "detail": "@AM"
         },
         {
            "key": "@Account",
            "icon": 21,
            "index": 3,
            "documentation": "Returns the name of the current jBASE user account.",
            "detail": "@ACCOUNT"
         },
         {
            "key": "@Application.Id",
            "icon": 21,
            "index": 4,
            "documentation": "@ID Dataname used to reference the record-id in a query language statement.",
            "detail": "@APPLICATION.ID"
         },
         {
            "key": "@Callstack",
            "icon": 21,
            "index": 5,
            "documentation": "For DEBUG purposes - returns the callstack if used in a subroutine.",
            "detail": "@CALLSTACK"
         },
         {
            "key": "@Codepage",
            "icon": 21,
            "index": 6,
            "documentation": "Returns the current JBASE_CODEPAGE setting when in I18N mode.",
            "detail": "@CODEPAGE"
         },
         {
            "key": "@Command",
            "icon": 21,
            "index": 7,
            "documentation": "See @SENTENCE.",
            "detail": "@COMMAND"
         },
         {
            "key": "@CR",
            "icon": 21,
            "index": 8,
            "documentation": "Inserts a carriage return CHAR(13).",
            "detail": "@CR"
         },
         {
            "key": "@Data",
            "icon": 21,
            "index": 9,
            "documentation": "Returns the data stack or input queue.",
            "detail": "@DATA"
         },
         {
            "key": "@Date",
            "icon": 21,
            "index": 10,
            "documentation": "Returns the internal date – on some systems, this differs from the DATE function in that the variable is set when program execution starts, whereas the function reflects the current date.",
            "detail": "@DATE"
         },
         {
            "key": "@Day",
            "icon": 21,
            "index": 11,
            "documentation": "Returns the day of the month from @DATE.",
            "detail": "@DAY"
         },
         {
            "key": "@Eof",
            "icon": 21,
            "index": 12,
            "documentation": "Returns the End of File character from the TTY characteristics.",
            "detail": "@EOF"
         },
         {
            "key": "@Esc",
            "icon": 21,
            "index": 13,
            "documentation": "Inserts a escape character CHAR(27).",
            "detail": "@ESC"
         },
         {
            "key": "@False",
            "icon": 21,
            "index": 14,
            "documentation": "Inserts a zero.",
            "detail": "@FALSE"
         },
         {
            "key": "@Ff",
            "icon": 21,
            "index": 15,
            "documentation": "Inserts a form feed chacater for printing CHAR(12).",
            "detail": "@FF"
         },
         {
            "key": "@Filename",
            "icon": 21,
            "index": 16,
            "documentation": "Returns the current filename, used in I-types.",
            "detail": "@FILENAME"
         },
         {
            "key": "@Fm",
            "icon": 21,
            "index": 17,
            "documentation": "Inserts an attribute/field mark CHAR(254).",
            "detail": "@FM"
         },
         {
            "key": "@Id",
            "icon": 21,
            "index": 18,
            "documentation": "Returns the current Item ID, used in I-types.",
            "detail": "@ID"
         },
         {
            "key": "@Im",
            "icon": 21,
            "index": 19,
            "documentation": "Inserts an item mark CHAR(255).",
            "detail": "@IM"
         },
         {
            "key": "@Level",
            "icon": 21,
            "index": 20,
            "documentation": "Returns the EXECUTE nesting level.",
            "detail": "@LEVEL"
         },
         {
            "key": "@Lf",
            "icon": 21,
            "index": 21,
            "documentation": "Inserts a line feed CHAR(10).",
            "detail": "@LF"
         },
         {
            "key": "@Locale",
            "icon": 21,
            "index": 22,
            "documentation": "Returns the current JBASE_LOCALE setting.",
            "detail": "@LOCALE"
         },
         {
            "key": "@Logname",
            "icon": 21,
            "index": 23,
            "documentation": "Returns the current operating system user name.",
            "detail": "@LOGNAME"
         },
         {
            "key": "@Lptrhigh",
            "icon": 21,
            "index": 24,
            "documentation": "Returns the number of lines on the device to which you are printing (terminal or printer).",
            "detail": "@LPTRHIGH"
         },
         {
            "key": "@Month",
            "icon": 21,
            "index": 25,
            "documentation": "Returns the number of the current month from @DATE.",
            "detail": "@MONTH"
         },
         {
            "key": "@Parasentence",
            "icon": 21,
            "index": 26,
            "documentation": "The last sentence or paragraph that invoked the current process.",
            "detail": "@PARASENTENCE"
         },
         {
            "key": "@Path",
            "icon": 21,
            "index": 27,
            "documentation": "Current working directory.",
            "detail": "@PATH"
         },
         {
            "key": "@Pid",
            "icon": 21,
            "index": 28,
            "documentation": "Current Process ID.",
            "detail": "@PID"
         },
         {
            "key": "@Record",
            "icon": 21,
            "index": 29,
            "documentation": "Returns the current record, used in I-types.",
            "detail": "@RECORD"
         },
         {
            "key": "@Rm",
            "icon": 21,
            "index": 30,
            "documentation": "Inserts a record mark CHAR(255).",
            "detail": "@TM"
         },
         {
            "key": "@Selected",
            "icon": 21,
            "index": 31,
            "documentation": "Returns the item count from the active select.",
            "detail": "@SELECTED"
         },
         {
            "key": "@Sentence",
            "icon": 21,
            "index": 32,
            "documentation": "The last sentence or paragraph that invoked the current process.",
            "detail": "@SENTENCE"
         },
         {
            "key": "@Sm",
            "icon": 21,
            "index": 33,
            "documentation": "Inserts a subvalue mark CHAR(252).",
            "detail": "@SM"
         },
         {
            "key": "@Svm",
            "icon": 21,
            "index": 34,
            "documentation": "Inserts a subvalue mark CHAR(252).",
            "detail": "@SVM"
         },
         {
            "key": "@Tab",
            "icon": 21,
            "index": 35,
            "documentation": "Inserts a tab character CHAR(9).",
            "detail": "@TAB"
         },
         {
            "key": "@Time",
            "icon": 21,
            "index": 36,
            "documentation": "Returns the current time in internal format.",
            "detail": "@TIME"
         },
         {
            "key": "@Timezone",
            "icon": 21,
            "index": 37,
            "documentation": "Returns the current JBASE_TIMEZONE setting.",
            "detail": "@TIMEZONE"
         },
         {
            "key": "@Tm",
            "icon": 21,
            "index": 38,
            "documentation": "Inserts a text mark CHAR(251).",
            "detail": "@TM"
         },
         {
            "key": "@True",
            "icon": 21,
            "index": 39,
            "documentation": "Inserts a one.",
            "detail": "@TRUE"
         },
         {
            "key": "@Tty",
            "icon": 21,
            "index": 40,
            "documentation": "Returns the current terminal device.",
            "detail": "@TTY"
         },
         {
            "key": "@Udtno",
            "icon": 21,
            "index": 41,
            "documentation": "Returns the current jBASE port number.",
            "detail": "@UDTNO"
         },
         {
            "key": "@Uid",
            "icon": 21,
            "index": 42,
            "documentation": "Returns the operating system user ID.",
            "detail": "@UID"
         },
         {
            "key": "@User",
            "icon": 21,
            "index": 43,
            "documentation": "Returns the operating system login name.",
            "detail": "@USER"
         },
         {
            "key": "@Userno",
            "icon": 21,
            "index": 44,
            "documentation": "Returns the jBASE port number.",
            "detail": "@USERNO"
         },
         {
            "key": "@Userstats",
            "icon": 21,
            "index": 45,
            "documentation": "Returns the current user statistics.",
            "detail": "@USERSTATS"
         },
         {
            "key": "@Vm",
            "icon": 21,
            "index": 46,
            "documentation": "Inserts a value mark CHAR(253).",
            "detail": "@VM"
         },
         {
            "key": "@Who",
            "icon": 21,
            "index": 47,
            "documentation": "Returns the name of the current jBASE account name.",
            "detail": "@WHO"
         },
         {
            "key": "@Year",
            "icon": 21,
            "index": 48,
            "documentation": "Returns the current two-digit year number.",
            "detail": "@YEAR"
         },
         {
            "key": "Abort",
            "icon": 14,
            "index": 49,
            "documentation": "The ABORT statement terminates the running program as well as the program that called it.\r\nThe optional message.number provided with the statement must be a numeric value, which corresponds to a record key in the jBASE error message file.\r\nA single expression or a list of expression(s) may follow the message.number.\r\nWhere more than one expression is listed, they must be delimited by use of the comma character.\r\nThe expression(s) correspond to the parameters that need to be passed to the error file record to print it.\r\nThe optional message.number and expression(s) given with the command are parameters or resultants provided as variables, literal strings, expressions, or functions.",
            "detail": "ABORT {message.number{, expression ...}}"
         },
         {
            "key": "Abs",
            "icon": 3,
            "index": 50,
            "documentation": "The ABS function will return the mathematical absolute of the ()expression.\r\nexpression can be an expression of any form that should evaluate to a numeric.\r\nThe ABS function will then return the mathematical absolute of the expression.\r\nThis will convert any negative number into a positive result.",
            "detail": "ABS(expression)"
         },
         {
            "key": "Abss",
            "icon": 3,
            "index": 51,
            "documentation": "Use the ABSS function to return the absolute values of all the elements in a dynamic array.\r\nIf an element in the dynamic array is null, it returns null for that element.",
            "detail": "ABSS(dynamic array)"
         },
         {
            "key": "Adds",
            "icon": 3,
            "index": 52,
            "documentation": "The ADDS function returns a dynamic array, the content of which is derived by adding corresponding elements from two dynamic arrays supplied as arguments.\r\nDynArr1 and DynArr2 represent dynamic arrays.",
            "detail": "ADDS(DynArr1, DynArr2)"
         },
         {
            "key": "Alpha",
            "icon": 3,
            "index": 53,
            "documentation": "The ALPHA function will check that the expression consists entirely of alphabetic characters.\r\nThe expression can return a result of any type. The ALPHA function will then return TRUE (1) if the expression consists entirely of alphabetic characters.\r\nIf any character in expression is non alphabetic then the function returns FALSE (0).",
            "detail": "ALPHA(expression)"
         },
         {
            "key": "Ands",
            "icon": 3,
            "index": 54,
            "documentation": "Use the ANDS function to create a dynamic array of the logical AND of corresponding elements from two dynamic arrays.\r\nEach element of the new dynamic array is the logical AND of the corresponding elements of array1 and array2.\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, it returns a false (0) for that element.\r\nIf both corresponding elements of array1 and array2 are null, it returns null for those elements.\r\nIf one element is a null value and the other is zero or an empty string, it returns false for those elements.",
            "detail": "ANDS(Array1, Array2)"
         },
         {
            "key": "Ascii",
            "icon": 3,
            "index": 55,
            "documentation": "The ASCII function converts all the characters in the expression from the EBCDIC character set to the ASCII character set.\r\nThe expression may return a data string of any form. The function will then assume that the characters are all members of the EBCDIC character set and translate them using a character map.\r\nThe original expression is unchanged while the returned result of the function is now the ASCII equivalent.",
            "detail": "ASCII(expression)"
         },
         {
            "key": "Assigned",
            "icon": 3,
            "index": 56,
            "documentation": "The ASSIGNED function returns a Boolean TRUE or FALSE result depending on whether a variable has been assigned a value or not.\r\nASSIGNED returns TRUE if the variable named has been assigned a value before the execution of this statement.\r\nIf the variable has never been assigned a value then the function returns FALSE.",
            "detail": "ASSIGNED(variable)"
         },
         {
            "key": "Begin Case",
            "icon": 14,
            "index": 57,
            "documentation": "The CASE structure is bounded by the BEGIN CASE and END CASE statements.",
            "detail": "BEGIN CASE\r\n\r\n...\r\nEND CASE"
         },
         {
            "key": "Bitand",
            "icon": 3,
            "index": 58,
            "documentation": "Use the BITAND function to perform the bitwise AND comparison of two integers specified by numeric expressions\r\nThe bitwise AND operation compares two integers bit by bit.\r\nIt returns a bit of 1 if both bits are 1; else, it returns a bit of 0.\r\nIf either expression1 or expression2 evaluates to a null value, null is returned.\r\nNon integer values are truncated before the operation is performed.\r\nThe BITAND operation is performed on a 32-bit twos-complement word.",
            "detail": "BITAND(expression1, expression2)"
         },
         {
            "key": "Bitchange",
            "icon": 3,
            "index": 59,
            "documentation": "BITCHANGE toggles the state of a specified bit in the local bit table, and return the original value of the bit.\r\n\r\ntable_no specifies the position in the table of the bit to be changed.\r\nA unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.\r\nBITCHANGE returns the value of the bit before it was changed.\r\nIt is therefore possible to check and set (or reset) a flag in one step.\r\nSome special functions ara available if one of the following table_no values is used:r\n-1 toggles (enables/disables) the BREAK key Inhibit bit.\r\n-2 toggles (enables/disables) the Command Level Restart feature.\r\n-3 toggles (enables/disables) the Break/End Restart feature.",
            "detail": "BITCHANGE(table_no)"
         },
         {
            "key": "Bitcheck",
            "icon": 3,
            "index": 60,
            "documentation": "BITCHECK returns the current value of a specified bit from the local bit table.\r\ntable_no specifies the position in the table of the bit to be checked.\r\nA unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.\r\nBITCHECK also provides some special functions if one of the following table_no values is used:\r\n-1 returns the setting of the BREAK key Inhibit bit.\r\n-2 returns the setting of the Command Level Restart feature.\r\n-3 returns the setting of the Break/End Restart feature.",
            "detail": "BITCHECK(table_no)"
         },
         {
            "key": "Bitload",
            "icon": 3,
            "index": 61,
            "documentation": "BITLOAD assigns all values in the local bit table, or retrieves all the values.bit-string is an ASCII string of characters which represent a hexadecimal value.\r\nIt is interpreted as a bit pattern and used to assign values to the table from left to right. Assignment stops at the end of the string or when a non-hexadecimal character is found.\r\nIf the string represents less than 128 bits, the remaining bits in the table are reset to 0 (zero).\r\nIf bit-string is omitted or evaluates to null, an ASCII hex character string is returned, which defines the value of the table. Trailing zeroes in the string are truncated.",
            "detail": "BITLOAD(bit_string)"
         },
         {
            "key": "Bitnot",
            "icon": 3,
            "index": 62,
            "documentation": "BITNOT returns the bitwise negation of an integer specified by any numeric expression.\r\nIf expression evaluates to the null value, null is returned.\r\nIf bit# evaluates to the null value, the BITNOT function fails and the program terminates with a run-time error message.\r\nNon integer values are truncated before the operation is performed.",
            "detail": "BITNOT(expression, bit#)"
         },
         {
            "key": "Bitor",
            "icon": 3,
            "index": 63,
            "documentation": "BITOR performs the bitwise OR comparison of two integers specified by numeric expressions.\r\nThe bitwise OR operation compares two integers bit by bit. It returns the bit 1 if the bit in either or both numbers is 1; else, it returns the bit 0.\r\nIf either expression1 or expression2 evaluates to the null value, null is returned.\r\nNon integer values are truncated before the operation is performed.",
            "detail":"BITOR(expression1, expression2)"
         },
         {
            "key": "Bitreset",
            "icon": 3,
            "index": 64,
            "documentation": "BITRESET resets the value of a specified bit in the local bit table to 0 and returns the value of the bit before it was changed.\r\ntable_no specifies the position in the table of the bit to be reset. If table_no evaluates to zero, all elements in the table are reset to 0 (zero) and the returned value is zero.\r\nA unique table of 128 bits (numbered 1 to 128) is maintained for each process.\r\nEach bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.",
            "detail":"BITRESET(table_no)"
         },
         {
            "key": "Bitset",
            "icon": 3,
            "index": 65,
            "documentation": "BITSET sets the value of a specified bit in the bit table to 1 and returns the value of the bit before it was changed.\r\ntable_no specifies the bit to be SET. If table_no evaluates to zero, all elements in the table are set to 1 (one) and the returned value is one.\r\nA unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.",
            "detail":"BITSET(table_no)"
         },
         {
            "key": "Bittest",
            "icon": 3,
            "index": 66,
            "documentation": "BITTEST tests the bit number of the integer specified by an expression.\r\nThe function returns 1 if the bit is set; it returns 0 if it is not; Bits are counted from right to left.\r\nThe number of the rightmost bit is 0.\r\nIf expression evaluates to the null value, null is returned. If bit# evaluates to null, the BITTEST function fails and the program terminates with a run-time error message.\r\nNon integer values are truncated before the operation is performed.",
            "detail":"BITTEST(expression, bit#)"
         },
         {
            "key": "Bitxor",
            "icon": 3,
            "index": 67,
            "documentation": "BITXOR performs the bitwise XOR comparison of two integers specified by numeric expressions.\r\nThe bitwise XOR operation compares two integers bit by bit.\r\nIt returns a bit 1 if only one of the two bits is 1; else, it returns a bit 0.\r\nIf either expression1 or expression2 evaluates to the null value, null is returned.\r\nNon integer values are truncated before the operation is performed.",
            "detail":"BITXOR(expression1, expression2)"
         },
         {
            "key": "Break",
            "icon": 14,
            "index": 68,
            "documentation": "The BREAK statement allows the break key to be configured.\r\nWhen used with an expression, or the keywords ON or OFF the BREAK statement enables or disables the BREAK key for the current process. In UNIX terms the BREAK key is more commonly known as the interrupt sequence intr defined by the stty command.\r\nUsed as a standalone statement, BREAK will terminate the currently executing loop. The EXIT statement is functionally equivalent to the BREAK statement used without arguments.",
            "detail":"BREAK\r\nBREAK ON\r\nBREAK OFF\r\nBREAK expression"
         },
         {
            "key": "Bytelen",
            "icon": 3,
            "index": 69,
            "documentation": "The BYTELEN function  will return the length of the expression as the number of bytes rather than the number of characters.\r\nThe expression can return a result of any type.\r\nThe BYTELEN function will then return the byte count of the expression.",
            "detail":"BYTELEN(expression)"
         },
         {
            "key": "Call",
            "icon": 14,
            "index": 70,
            "documentation": "The CALL statement transfers program execution to the subroutine called subroutine.name, which can be any valid string either quoted or unquoted.\r\nThe CALL @ variant of this statement assumes that subroutine.name is a variable that contains the name of the subroutine to call.\r\nThe CALL statement may optionally pass a number of parameters to the target subroutine.\r\nThese parameters can consist of any valid expression or variable name.\r\nIf a variable name is used then the called program may return a value to the variable by changing the value of the equivalent variable in its own parameter list.",
            "detail": "CALL {@}subroutine.name {(argument {, argument ... })}"
         },
         {
            "key": "Callc",
            "icon": 14,
            "index": 71,
            "documentation": "The CALLC statement is used to invoke user supplied C functions compiled and built into standard libraries.\r\nCfunction must correspond to a valid C function name in an associated C source.\r\nargument must correspond to a valid variable name\r\nVariable must correspond to a valid variable name which contains the name of the C function to invoke.\r\nThe indirect, '@', form of the statement expects the specified variable to contain the name of the 'C' function to be invoked.\r\nAll arguments to be passed to and from the calling program to the 'C' function must be of type VAR and the 'C' function coded accordingly, the 'C' function should also be coded to return a result of type VAR.\r\nRefer to the jsystem.h header file and jBASE 'C' programming for more information on the jBASE VAR type.\r\nThe 'C' functions should be coded in a separate source, then compiled and built into a shared library and made available to the calling program similar to subroutines",
            "detail": "CALLC Cfunction{(argument{,...})}\r\nor\r\nCALLC @Variable{(argument {, argument ... })}"
         },
         {
            "key": "Calldotnet",
            "icon": 14,
            "index": 72,
            "documentation": "The CALLdotNET command allows jBASE BASIC to call any .NET assembly and is useful when using third party applications.\r\nNameSpaceAndClassName The “full” NameSpace (e.g., myNameSpace.myClass)\r\nmethodName The name of the .NET in this class (e.g., “myMethod”)\r\nParam Any parameter (e.g. DynArray)",
            "detail": "CALLdotNET NameSpaceAndClassName, methodName, param SETTING ret [ON ERROR errStatment]"
         },
         {
            "key": "Callj",
            "icon": 14,
            "index": 73,
            "documentation": "The CALLJ statement allows a jBC program to call a Java method.\r\npackageAndClassName The “full” class name (e.g., com.jbase.util.utilClass).\r\nmethodName The name of the Java method in this class (e,g., “myMethod”). If the method is static, you must include a ‘$’ before the name. This ‘$’ will be removed from the method name before calling it.\r\nparam Any parameter (e.g. DynArray)",
            "detail": "CALLJ packageAndClassName, [$]methodName, param SETTING ret [ON ERROR] statements"
         },
         {
            "key": "Callonexit",
            "icon": 3,
            "index": 74,
            "documentation": "The CALLONEXIT function call allows you to specify the name of a SUBROUTINE to call when the program terminates.\r\nThe subroutine definition would look like this\r\n\r\nSUBROUTINE CALLONEXIT(parm1)\r\n\r\nYou can add parameters to the error subroutine by adding multi-values to the parameter to CALLONEXIT, which are passed to the called subroutine in the first parameter.\r\nIf you execute CALLONEXIT multiple times with the same subroutine name, it discards other calls.\r\nIf you execute CALLONEXIT multiple times with a different subroutine name, then upon exit multiple subroutines will be called in the order that CALLONEXIT was called.",
            "detail": "rc = CALLONEXIT('ErrorExit')"
         },
         {
            "key": "Case",
            "icon": 14,
            "index": 75,
            "documentation": "The CASE statement allows the programmer to execute a particular sequence of instructions based upon the results of a series of test expressions.\r\nThe CASE structure is bounded by the BEGIN CASE and END CASE statements.\r\nWithin this block, an arbitrary number of CASE expression statements may exist followed by any number of jBC statements.\r\nThe expression should evaluate to a TRUE or FALSE result.\r\nAt execution time, each expression is evaluated in order.\r\nIf the expression returns a TRUE result, then the statements beneath it are executed.\r\nOn completion of the associated statements, execution will resume at the first statement following the END CASE.",
            "detail": "CASE expression\r\nstatement(s)\r\nCASE expression\r\nstatement(s)\r\n.....\r\nEND CASE"
         },
         {
            "key": "Cats",
            "icon": 3,
            "index": 76,
            "documentation": "The CATS function concatenates the corresponding elements in two dynamic arrays.\r\nDynArr1 and DynArr2 represent dynamic arrays.\r\nIf one dynamic array supplied to the CATS function is null then the result of the CATS function is the non-null dynamic array.",
            "detail": "CATS(DynArr1, DynArr2)"
         },
         {
            "key": "Chain",
            "icon": 14,
            "index": 77,
            "documentation": "The CHAIN statement exits the current program and transfers process control to the program defined by the expression.\r\nProcess control will never return to the originating program.\r\nThe expression should evaluate to a valid UNIX or Windows command (this may be another jBC program).\r\nThe command string may be suffixed with the (I option, which will cause any COMMON variables in the current program to be inherited by the new program (providing it is a jBC program).",
            "detail": "CHAIN expression {(I}"
         },
         {
            "key": "Change",
            "icon": 3,
            "index": 78,
            "documentation": "The CHANGE function operates on a variable and replaces all occurrences of one string with another.\r\nexpression1 may evaluate to any result and is the string of characters that will be replaced.\r\nexpression2 may also evaluate to any result and is the string of characters that will replace expression1.\r\nThe variable may be any previously assigned variable in the program.\r\nEither string can be of any length and is not required to be the same length.\r\nSee also the SWAP function.\r\nThe jBC language also supports the CHANGE statement.",
            "detail": "CHANGE( variable, expression1, expression2 )"
         },
         {
            "key": "Change",
            "icon": 14,
            "index": 79,
            "documentation": "The CHANGE statement operates on a variable and replaces all occurrences of one string with another.\r\nexpression1 may evaluate to any result and is the string of characters that will be replaced,\r\nexpression2 may also evaluate to any result and is the string of characters that will replace expression1,\r\nvariable may be any previously assigned variable in the program.\r\nThere is no requirement that strings be of the same length. ",
            "detail": "CHANGE expression1 TO expression2 IN variable"
         },
         {
            "key": "Changetimestamp",
            "icon": 3,
            "index": 80,
            "documentation": "Use CHANGETIMESTAMP to adjust existing timestamp to return new timestamp value.\r\nThe CHANGETIMESTAMP function generates a new timestamp by adjusting an existing timestamp value using the elements specified in the dynamic array.\r\nThe format of the adjustment array is as follows:\r\nYears^Months^Weeks^Days^Hours^Minutes^Seconds^Milliseconds",
            "detail": "CHANGETIMESTAMP(Timestamp, Array)"
         },
         {
            "key": "Char",
            "icon": 3,
            "index": 81,
            "documentation": "The CHAR function returns the  ASCII character specified by the expression.\r\nThe expression must evaluate to a numeric argument in the range 0-255.\r\n\r\nInternational Mode\r\nThe CHAR function will return Unicode values encoded as UTF-8 byte sequences as follows:\r\nExpression values 0 – 127 return UTF-8 single byte characters equivalent to ASCII.\r\nExpression values 127 – 248 return UTF-8 double byte character sequences.\r\nExpression values 249 – 255 return system delimiters 0xf8 – 0xff\r\nExpression values > 255 return UTF-8 multi byte character sequences\r\nWhen system delimiter values are not specifically required, generate UTF-8 byte sequences using the UTF8 function. i.e. X = UTF8(@AM) will generate a UTF-8 byte sequence in variable X for the system delimiter equating to Unicode value 0x000000fe.",
            "detail": "CHAR(expression)"
         },
         {
            "key": "Chars",
            "icon": 3,
            "index": 82,
            "documentation": "The CHARS function accepts a dynamic array of numeric expressions and returns a dynamic array of the corresponding ASCII characters\r\nEach element of DynArr must evaluate to a numeric argument in the range 0-255.\r\nIf any of the dynamic array elements are non-numeric, a run-time error will occur.\r\nSee also CHAR().",
            "detail": "CHARS(DynArr)"
         },
         {
            "key": "Chdir",
            "icon": 3,
            "index": 83,
            "documentation": "The CHDIR function allows the current working directory, as seen by the process environment, to be changed.\r\nThe expression should evaluate to a valid path name within the file system.\r\nThe function returns a Boolean TRUE result if the CHDIR succeeded and a Boolean FALSE result if it failed.",
            "detail": "CHDIR(expression)"
         },
         {
            "key": "Checksum",
            "icon": 3,
            "index": 84,
            "documentation": "The CHECKSUM function returns a simple numeric checksum of a character string.\r\nThe expression may evaluate to any result but will usually be a string.\r\nThe function then scans every character in the string and returns a numeric addition of the characters within the string.\r\nThe function calculates the checksum by summing the product of the ASCII value of each character and its position within the string.",
            "detail": "CHECKSUM(expression)"
         },
         {
            "key": "Clear",
            "icon": 14,
            "index": 85,
            "documentation": "The CLEAR statement will initialize all variables to numeric 0.\r\nCLEAR can be used at any time during the execution of the program.",
            "detail": "CLEAR"
         },
         {
            "key": "Clearcommon",
            "icon": 14,
            "index": 86,
            "documentation": "The CLEARCOMMON statement initializes all unnamed common variables to a value of zero.",
            "detail": "CLEARCOMMON"
         },
         {
            "key": "Cleardata",
            "icon": 14,
            "index": 87,
            "documentation": "The CLEARDATA statement clears data that has been stacked by the DATA statement.",
            "detail": "CLEARDATA"
         },
         {
            "key": "Clearfile",
            "icon": 14,
            "index": 88,
            "documentation": "The CLEARFILE statement is used to clear all the data from a file previously opened with the OPEN statement.\r\nThe variable must have been the subject of an OPEN statement before the execution of CLEARFILE upon it.\r\nIf the variable is omitted from the CLEARFILE statement, then the default file variable is assumed as per the OPEN statement.\r\nThe CLEARFILE statement will remove every database record on the file it is executed against. It should therefore be used with great care.\r\nIf the variable argument does not describe a previously opened file, the program will enter the debugger with an appropriate message.",
            "detail": "CLEARFILE {variable} {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Clearinput",
            "icon": 14,
            "index": 89,
            "documentation": "The CLEARINPUT statement clears the type-ahead buffer to allow the next INPUT statement to force a response from the user.\r\nCLEARINPUT only clears the type-ahead buffer.\r\nIt does not clear data stacked with the DATA statement.\r\nThe CLEARINPUT statement is synonymous with INPUTCLEAR.",
            "detail": "CLEARINPUT"
         },
         {
            "key": "Clearselect",
            "icon": 14,
            "index": 90,
            "documentation": "The CLEARSELECT statement is used to clear specific active select lists.\r\nCListName must evaluate to a jBC list variable.\r\nListNumber is one of the numbered lists in the range 0 to 11.\r\nIf neither ListName or ListNumber are specified then the default list (0) is cleared.",
            "detail": "CLEARSELECT {ListName | ListNumber}"
         },
         {
            "key": "Close",
            "icon": 14,
            "index": 91,
            "documentation": "The statement is used to CLOSE a previously opened file when it is no longer needed.\r\nItem locks and file locks are released.\r\nThe variable list should contain previously opened file variables that are no longer needed.\r\nThe variables will be cleared and may be reused as ordinary variables.",
            "detail": "CLOSE variable{, variable ...}"
         },
         {
            "key": "Closeseq",
            "icon": 14,
            "index": 92,
            "documentation": "The statement is used to CLOSE a file previously opened for sequential access.\r\nFileVar contains the file descriptor of the previously opened sequential file",
            "detail": "CLOSESEQ FileVar"
         },
         {
            "key": "Col1",
            "icon": 3,
            "index": 93,
            "documentation": "The function is used in conjunction with the FIELD function to determine the character position 1 position before the last field that was located.\r\nWhen a field has been located in a string, it is sometimes useful to know its exact position within the string to manipulate either it, or the rest of the string. COL1() will return the position of the character immediately before the last field located.",
            "detail": "COL1()"
         },
         {
            "key": "Col2",
            "icon": 3,
            "index": 94,
            "documentation": "The function is used in conjunction with the FIELD function to determine the character position 1 position after the last field that was located.\r\nCOL2() will return the position of the character immediately after the end of the last field located. Together with COL1(), they can then be used to manipulate the string.",
            "detail": "COL2()"
         },
         {
            "key": "Collectdata",
            "icon": 14,
            "index": 95,
            "documentation": "The COLLECTDATA statement is used to retrieve data passed from the PASSDATA clause of an EXECUTE statement.\r\nvariable is the name of the variable which is to store the retrieved data.\r\nThe COLLECTDATA statement can be used in any program which is EXECUTEd (or PERFORMed) by another program where the calling program uses a PASSDATA clause.\r\nThe EXECUTEd program uses a COLLECTDATA statement to retrieve the passed data.\r\nIf a PASSDATA clause is not in effect, variable will be assigned a value of null.",
            "detail": "COLLECTDATA variable"
         },
         {
            "key": "Common",
            "icon": 14,
            "index": 96,
            "documentation": "The COMMON statement declares a list of variables and matrices that can be shared among various programs.\r\nThere can be many common areas including a default, unnamed common area.\r\nThe list of variables should not have been declared or referenced previously in the program file.\r\nThe compiler will detect any bad declarations and display suitable warning or error messages.\r\nIf the common area declared with the statement is to be named then the first entry in the list should be a string, delimited by the / character.",
            "detail": "COMMON {/CommonName/} variable{, variable ... }"
         },
         {
            "key": "Compare",
            "icon": 3,
            "index": 97,
            "documentation": "The COMPARE function compares two strings and returns a value indicating whether or not they are equal.\r\nexpression1 is the first string for comparison\r\nexpression2 is the second string for comparison\r\njustification specifies how the strings are to be compared.\r\n\"L\" indicates a left justified comparison.\r\n\"R\" indicates a right justified comparison.\r\nThe default is left justification.",
            "detail": "COMPARE(expression1, expression2{, justification})"
         },
         {
            "key": "Continue",
            "icon": 14,
            "index": 98,
            "documentation": "The CONTINUE statement is the complimentary statement to the BREAK statement without arguments.\r\nThe statement is used within a loop to skip the remaining code in the current iteration and proceed directly to the next iteration.\r\nSee also: BREAK, EXIT\r\nThe compiler will issue a warning message and ignore the statement if it is found outside an iterative loop such as FOR...NEXT, LOOP...REPEAT.",
            "detail": "CONTINUE"
         },
         {
            "key": "Convert",
            "icon": 3,
            "index": 99,
            "documentation": "This is the function form of the CONVERT statement.\r\nIt performs exactly the same function, but may also operate on an expression rather than being restricted to variables.\r\nexpression1 is the string to which the conversion will apply.\r\nexpression2 is the list of all characters to translate in expression1.\r\nexpression3 is the list of characters that will be converted to.\r\n\r\nFor Prime, Universe and Unidata emulations:\r\nexpression1 is the list of all characters to translate in expression1.\r\nexpression2 is the list of characters that will be converted to.\r\nexpression3 is the string to which the conversion will apply.",
            "detail": "CONVERT(expression1, expression2, expression3)"
         },
         {
            "key": "Convert",
            "icon": 14,
            "index": 100,
            "documentation": "The CONVERT statement converts one or more characters in a string to their corresponding replacement characters.\r\nexpression1 is the list of all characters to translate in expression3.\r\nexpression2 is the list of characters that will be converted to.\r\nexpression3 is the string to which the conversion will apply.",
            "detail": "CONVERT expression1 TO expression2 IN expression3"
         },
         {
            "key": "Cos",
            "icon": 3,
            "index": 101,
            "documentation": "The COS function calculates the cosine of any angle using floating point arithmetic, then rounds to the precision implied by the jBC program. This makes it very accurate.\r\nThe expression must evaluate to a numeric result or a runtime error will occur.",
            "detail": "COS(expression)"
         },
         {
            "key": "Count",
            "icon": 3,
            "index": 102,
            "documentation": "The COUNT function returns the number of times that one string occurs in another.\r\nBoth expression1 and expression2 may evaluate to any data type but logically they will evaluate to character strings.\r\nThe count is made on overlapping occurrences as a pattern match from each character in expression1.\r\nThis means that the string jjj occurs 3 times in the string jjjjj.",
            "detail": "COUNT(expression1, expression2)"
         },
         {
            "key": "Counts",
            "icon": 3,
            "index": 103,
            "documentation": "The COUNTS function counts the number of times a substring is repeated in each element of a dynamic array.\r\nThe result is a new dynamic array whose elements are the counts corresponding to the elements in the dynamic array.\r\ndynamic.array specifies the dynamic array whose elements are to be searched.\r\nsubstring is an expression that evaluates to the substring to be counted. substring can be a character string, a constant, or a variable. Each character in an element is matched to substring only once.\r\nTherefore, when substring is longer than one character and a match is found, the search continues with the character following the matched substring.\r\nNo part of the matched element is recounted toward another match.\r\nIf substring does not appear in an element, a 0 value is returned. If substring is an empty string, the number of characters in the element is returned.\r\nIf substring is null, the COUNTS function fails and the program terminates with a run-time error message.\r\nIf any element in dynamic.array is null, null is returned.",
            "detail": "COUNTS(dynamic array, substring)"
         },
         {
            "key": "Create",
            "icon": 14,
            "index": 104,
            "documentation": "Use the CREATE statement after an OPENSEQ statement to create a record in a jBASE directory file or to create a UNIX or DOS file.\r\nCREATE creates the record or file if the OPENSEQ statement fails.\r\nAn OPENSEQ statement for the specified file.variable must be executed before the CREATE statement to associate the pathname or record ID of the file to be created with the file.variable.\r\nIf file.variable is null, the CREATE statement fails and the program enters the debugger.\r\nUse the CREATE statement when OPENSEQ cannot find a record or file to open and the next operation is to be a READSEQ or READBLK.\r\nIf the first file operation is a WRITESEQ, WRITESEQ creates the record or file if it does not exist.\r\nIf the record or file is created, it executes the THEN statements; if no record or file is created, it executes the ELSE statements.",
            "detail": "CREATE file.variable {THEN statements [ELSE statements] | ELSE statements}"
         },
         {
            "key": "Crt",
            "icon": 14,
            "index": 105,
            "documentation": "The CRT statement sends data directly to the terminal, even if a PRINTER ON statement is currently active.\r\n\r\nAn expression can evaluate to any data type.\r\nThe CRT statement will convert the result to a string type for printing.\r\nExpressions separated by commas will be sent to the screen separated by a tab character.\r\nThe CRT statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character.",
            "detail": "CRT expression {, expression..} {:}"
         },
         {
            "key": "Data",
            "icon": 14,
            "index": 106,
            "documentation": "The DATA statement stacks the series of expressions on an input FIFO stack.\r\nTerminal input statements will then treat this data as if it were typed in at the keyboard\r\nThe expression may evaluate to any data type.\r\nEach comma separated expression will be viewed as one line of terminal input.\r\nThe DATA statement cannot be used to send input to the jBC IN statement in that the IN statement reads from a different location than the INPUT statement.\r\nThe INPUT statement reads from stdin and IN reads from the 'raw' device (normally the keyboard). ",
            "detail": "DATA expression {, expression ...}"
         },
         {
            "key": "Date",
            "icon": 3,
            "index": 107,
            "documentation": "The DATE() function returns the date in internal system form. This date is expressed as the number of days before or after December 31, 1967.\r\nThe system and any programs should manipulate date fields in internal form.\r\nThey can then be converted to a readable format of your choice using the OCONV() function and the date conversion codes.\r\nSee also: TIMEDATE()",
            "detail": "DATE()"
         },
         {
            "key": "Dcount",
            "icon": 3,
            "index": 108,
            "documentation": "The DCOUNT() function counts the number of field elements in a string that are separated by a specified delimiter.\r\nexpression1 evaluates to a string in which fields are to be counted.\r\nexpression2 evaluates to the delimiter string that will be used to count the fields.\r\nThe delimiter string may consist of more than 1 character.\r\nIf expression1 is a NULL string, then the function will return a value of 0.\r\nThe delimiter string may consist of any character, including system delimiters such as field marks or value marks.\r\nSee also COUNT.",
            "detail": "DCOUNT(expression1, expression2)"
         },
         {
            "key": "Debug",
            "icon": 14,
            "index": 109,
            "documentation": "The DEBUG statement causes the executing program to enter the jBC debugger.",
            "detail": "DEBUG"
         },
         {
            "key": "Decrypt",
            "icon": 3,
            "index": 110,
            "documentation": "The DECRYPT function decodes a string encrypted by the ENCRYPT function.\r\nstring specifies the string to be decrypted.\r\nkey is the value used to decrypt the string. It's use depends on method.\r\nmethod is a number which indicates the decryption mechanism to use:\r\n0\tGeneral purpose encryption scheme.\r\n\tThis method will decrypt the string using the key value supplied.\r\n1\tSimple ROT13 algorithm.\r\n\tkey not used.\r\n2\tXOR MOD11 algorithm.\r\n\tThe first character of key is used as a seed value.\r\nSee also ENCRYPT.",
            "detail": "DECRYPT(string, key, method)"
         },
         {
            "key": "Defc",
            "icon": 14,
            "index": 111,
            "documentation": "The DEFC statement is used to declare an external C function to the jBC compiler and define its arguments and return types.\r\nFuncType and ArgType are selected from one of INT, FLOAT or VAR.\r\nFuncType specifies the type of result that the function will return.\r\nIf FuncType is omitted then INT will be assumed.\r\nThe optional list of ArgTypes specifies the argument types that the C function will expect.\r\nThe compiler must know this in advance as it will automatically perform type conversions on these arguments.",
            "detail": "DEFC {FuncType} FuncName ({ArgType {, ArgType ...}})"
         },
         {
            "key": "Defce",
            "icon": 14,
            "index": 112,
            "documentation": "The DEFCE statement should be used, rather than the DEFC statement, for calling external C programs, which are pure ‘C’ code and do not use the jBASE library macros and functions.\r\nThe arguments passed can only be of type INT, FLOAT and STRING.",
            "detail": "DEFCE {FuncType} FuncName ({ArgType {, ArgType ...}})"
         },
         {
            "key": "Deffun",
            "icon": 14,
            "index": 113,
            "documentation": "The DEFFUN statement is used to declare an external jBC function to the jBC compiler and optionally define its arguments.\r\nDEFFUN is used in the program that calls the function.\r\nFuncName is the name used to define the function.\r\nIt must be the same as the source file name.\r\nArgument specifies a value that is passed to the function by the calling program.\r\nTo pass an array, the keyword MAT must be used before the argument name.\r\nThese parameters are entirely optional (as indicated in the Command Syntax), but can be specified for clarity.\r\nNote that if the arguments are not initialized somewhere in the program you will receive a compiler warning.\r\nThe DEFFUN statement identifies a user-written function to the jBC compiler.\r\nIt must be present in each program that calls the function, before the function is called.\r\nA hidden argument is passed to the function so that a value can be returned to the calling program.\r\nThe return value is set in the function using the  RETURN (value) statement.\r\nIf the RETURN statement specifies no value then an empty string is returned by the function.",
            "detail": "DEFFUN FuncName  ({ {MAT} Argument1, {MAT} Argument2...})"
         },
         {
            "key": "Del",
            "icon": 3,
            "index": 114,
            "documentation": "The DEL statement or legacy DELETE function is used to remove a specified element from a dynamic array.\r\nThe variable can be any previously assigned variable or matrix element.\r\nThe expressions must evaluate to a numeric value or a runtime error will occur.\r\nexpression1 specifies the field in the array to operate upon and must be present.\r\nexpression2 specifies the multivalue within the field to operate upon and is an optional parameter.\r\nexpression3 is optionally present when expression2 has been included.\r\nIt specifies which subvalue to delete within the specified multivalue.",
            "detail": "DEL variable<expression1{, expression2{, expression3}}>\r\nDELETE(variable,expression1{, expression2{, expression3})"
         },
         {
            "key": "Delete",
            "icon": 14,
            "index": 115,
            "documentation": "The DELETE statement is used to delete a record from a jBASE file.\r\nIf specified, variable should have been the subject of a previous OPEN statement.\r\nIf variable is omitted then the default file variable is assumed.\r\nThe expression should evaluate to the name of a record stored in the open file.",
            "detail": "DELETE {variable,} expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Deletelist",
            "icon": 14,
            "index": 116,
            "documentation": "The DELETELIST statement will delete the previously stored list named by the expression.\r\nThe expression should evaluate to the name of a list that has been stored either with the WRITELIST statement or the SAVE-LIST command from the shell.",
            "detail": "DELETELIST expression"
         },
         {
            "key": "Deleteseq",
            "icon": 14,
            "index": 117,
            "documentation": "DELETESEQ deletes an operating system file.\r\nExpression specifies the explicit path of an operating system file to delete.\r\nExpression, Filename Filename is a file that resides in the directory path specified by Expression\r\nStatements conditional jBC statements",
            "detail": "DELETESEQ Expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN | ELSE statements\r\nor\r\nDELETESEQ Expression, Filename {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN | ELSE statements"
         },
         {
            "key": "Deleteu",
            "icon": 14,
            "index": 118,
            "documentation": "Use the DELETEU statement to delete a record without releasing the update record lock set by a previous READU statement.\r\nIf no file variable is specified in the DELETEU statement, the statement applies to the default file.",
            "detail": "DELETEU {variable,} expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Dim",
            "icon": 14,
            "index": 119,
            "documentation": "The DIM statement is used to declare arrays to the compiler before they are referenced.\r\nThe variable may be any valid variable name that has not already been used or declared.\r\nThe numbers define the size of each dimension and must be either constants or the subject of an EQUATE statement.\r\nA number of arrays may be declared by a single DIM statement by separating their declarations with a comma.\r\nThe array must be declared before it is referenced in the program source (compilation as opposed to execution).\r\nThe compiler will display an error message if a variable is used as a dimensioned array before it has been declared.\r\nThe array variable may not be used as a normal variable or dynamic array before being dimensioned and the compiler will detect this as an error.\r\nA dimension size may not be specified as 1 as this has no logical meaning.\r\nThe compiler will detect this as a warning.\r\nWhen arrays are referenced directly as in A = Array(7), the compiler will optimize the reference as if it was a single undimensioned variable.\r\nIf the emulation option 'resize_array=true' is set, then the array may be dimensioned with a variable.\r\nIt can also be resized (i.e. redimensioned).",
            "detail": "DIM{ENSION} variable(number{, number... }){, variable(number {,number...}) ...}"
         },
         {
            "key": "Dimension",
            "icon": 14,
            "index": 120,
            "documentation": "The DIMENSION statement is used to declare arrays to the compiler before they are referenced.\r\nThe variable may be any valid variable name that has not already been used or declared.\r\nThe numbers define the size of each dimension and must be either constants or the subject of an EQUATE statement.\r\nA number of arrays may be declared by a single DIM statement by separating their declarations with a comma.\r\nThe array must be declared before it is referenced in the program source (compilation as opposed to execution).\r\nThe compiler will display an error message if a variable is used as a dimensioned array before it has been declared.\r\nThe array variable may not be used as a normal variable or dynamic array before being dimensioned and the compiler will detect this as an error.\r\nA dimension size may not be specified as 1 as this has no logical meaning.\r\nThe compiler will detect this as a warning.\r\nWhen arrays are referenced directly as in A = Array(7), the compiler will optimize the reference as if it was a single undimensioned variable.\r\nIf the emulation option 'resize_array=true' is set, then the array may be dimensioned with a variable.\r\nIt can also be resized (i.e. redimensioned).",
            "detail": "DIMENSION variable(number{, number... }){, variable(number {,number...}) ...}"
         },
         {
            "key": "Dir",
            "icon": 3,
            "index": 121,
            "documentation": "The DIR function returns information about a file.The filename is a string argument representing the path and filename of a file.\r\nThis function returns a dynamic array with four attributes.\r\nAttribute\tDescription\r\n1\tFile size in Bytes\r\n2\tLast modified date (in internal format)\r\n3\tLast modified time (in internal format)\r\n4\t'D' if the filename is a directory, blank if the filename is a file",
            "detail": "DIR(filename)"
         },
         {
            "key": "Display",
            "icon": 14,
            "index": 122,
            "documentation": "The DISPLAY statement sends data directly to the terminal, even if a PRINTER ON statement is currently active.\r\nAn expression can evaluate to any data type.\r\nThe DISPLAY statement will convert the result to a string type for printing.\r\nExpressions separated by commas will be sent to the screen separated by a tab character.\r\nThe DISPLAY statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character.\r\nAs the expression can be any valid expression, it may have output formatting applied to it.\r\nA jBC program is normally executed using buffered output mode.\r\nThis means that data is not flushed to the terminal screen unless a newline sequence is printed or terminal input is requested and makes it very efficient.\r\nHowever you can force output to be flushed to the terminal by printing a null character 'CHAR(0)'.\r\nThis has the same effect as a newline sequence but without affecting screen output.",
            "detail": "DISPLAY expression {, expression..} {:}"
         },
         {
            "key": "Div",
            "icon": 3,
            "index": 123,
            "documentation": "The DIV function  calculates the value of the quotient after division of the dividend by the divisor.\r\nThe dividend and divisor expressions can evaluate to any numeric value.\r\nThe only exception is that the divisor cannot be zero.\r\nIf either dividend or divisor evaluates to null, it returns null.",
            "detail": "DIV(dividend, divisor)"
         },
         {
            "key": "Divs",
            "icon": 3,
            "index": 124,
            "documentation": "The DIVS function returns a dynamic array, the content of which is derived by dividing each element of the first dynamic array argument by the corresponding element of the second dynamic array argument.\r\nDynArr1 and DynArr2 represent dynamic arrays.\r\nNull elements of argument arrays are treated as zero.\r\nOtherwise, a non-numeric element in an argument array will cause a run-time error.\r\nIf a zero value element in DynArr2 has a corresponding element in DynArr1, then a run-time error will occur.\r\nIf a zero value element in DynArr2 does not have a corresponding element in DynArr1, then the corresponding element in the result array will be zero.",
            "detail": "DIVS(DynArr1, DynArr2)"
         },
         {
            "key": "Downcase",
            "icon": 3,
            "index": 125,
            "documentation": "DOWNCASE converts all uppercase characters in an expression to lowercase characters.\r\nexpression in a string containing alphabetic characters.\r\nNon-alphabetic characters are ignored.\r\nThe function LOWCASE is synonymous with DOWNCASE.",
            "detail": "DOWNCASE(expression)"
         },
         {
            "key": "Dquote",
            "icon": 3,
            "index": 126,
            "documentation": "The function will put double quotation mark at the beginning and end of a string.\r\nexpression may be any expression that is valid in the JBC language.",
            "detail": "DQUOTE(Expression)"
         },
         {
            "key": "Dround",
            "icon": 3,
            "index": 127,
            "documentation": "The DROUND( ) function performs double-precision rounding on a value.\r\nexpression1 is the value to round.\r\nexpression2 is the optional precision.\r\nDouble-precision rounding uses 2 words to store a number.\r\nIf a precision is not specified as the second expression, DROUND() uses whatever precision is set at the time of the calculation.\r\nIf no PRECISION statement was issued then the default precision of 4 is used.\r\nThe specified precision (either with the PRECISION statement or with the optional precision parameter) to be greater than or equal to the rounding digit, otherwise the calculation will truncate the value to the whatever precision is 'active' at the time of the calculation.",
            "detail": "DROUND(expression1{, expression2})"
         },
         {
            "key": "Dtx",
            "icon": 3,
            "index": 128,
            "documentation": "The DTX function will return the hexadecimal representation of a numeric expression.\r\nexpression must evaluate to a decimal numeric value or a runtime error will occur.",
            "detail": "DTX(expression)"
         },
         {
            "key": "Dyntoxml",
            "icon": 3,
            "index": 129,
            "documentation": "The DYNTOXML function converts a dynamic array to XML.\r\nConvert an array to XML using the optional xsl to transform\r\nTakes the contents of the dynamic array and returns a generic XML representation of that array or an error",
            "detail": "DYNTOXML(array,xsl,result)"
         },
         {
            "key": "Ebcdic",
            "icon": 3,
            "index": 130,
            "documentation": "The EBCDIC function converts all the characters in an expression from the ASCII character set to the EBCDIC character set.\r\nexpression may contain a data string of any form.\r\nThe function will convert it to a character string, assuming that the characters are all members of the ASCII set and translate them using a character map.\r\nThe original expression is unchanged while the result of the function is now the EBCDIC equivalent.",
            "detail": "EBCDIC(expression)"
         },
         {
            "key": "Echo",
            "icon": 14,
            "index": 131,
            "documentation": "The ECHO statement will turn on or off the echoing of characters typed at the keyboard.\r\nThe statement may be used with the keywords ON and OFF to specify echoing or not.\r\nIf used with an expression, then the expression should evaluate to a Boolean TRUE or FALSE result.\r\nIf TRUE then echoing will be turned on, and if FALSE, echoing will be turned off.\r\nThe SYSTEM function can be used to determine the current state of character echoing.\r\nIf echoing is enabled then SYSTEM(24) will return Boolean TRUE and if disabled it will return Boolean FALSE.",
            "detail": "ECHO ON\r\nECHO OFF\r\nECHO expression"
         },
         {
            "key": "Encrypt",
            "icon": 3,
            "index": 132,
            "documentation": "The ENCRYPT function encrypts a string.\r\nstring specifies the string to be encrypt.\r\nkey is the value used to encrypt the string. It's use depends on method.\r\nmethod is a number which indicates the encryption mechanism to use:\r\n0\tGeneral purpose encryption scheme.\r\n\tThis method will encrypt the string using the key value supplied.\r\n1\tSimple ROT13 algorithm.\r\n\tkey not used.\r\n2\tXOR MOD11 algorithm.\r\n\tThe first character of key is used as a seed value.\r\nSee also DECRYPT.",
            "detail": "ENCRYPT(string, key, method)"
         },
         {
            "key": "End",
            "icon": 14,
            "index": 133,
            "documentation": "The END statement is used to terminate a program or to conclude a set of jBC statements bounded by a condition.\r\nThe END statement is not required in a jBC program.\r\nIf the compiler encounters an END statement that is not the conclusion to a conditional block, then no statements can follow it.",
            "detail": "END"
         },
         {
            "key": "End Case",
            "icon": 14,
            "index": 134,
            "documentation": "The END CASE statement terminates a CASE block. There should be a corresponding END CASE for each BEGIN CASE.",
            "detail": "END CASE"
         },
         {
            "key": "End Else",
            "icon": 14,
            "index": 135,
            "documentation": "The END ELSE terminates the THEN portion and begin the ELSE portion of a code block",
            "detail": "END ELSE"
         },
         {
            "key": "Enter",
            "icon": 14,
            "index": 136,
            "documentation": "The ENTER statement unconditionally passes control to another executable program.\r\nprogram_name is the name of the program to be executed.\r\nThe use of single or double quotes to surround program_name is optional.\r\n@ specifies that the program name is contained in a named variable.\r\nvariable_name is the name of the variable which contains the program name.\r\nThe jBC COMMON data area can be passed to another jBC program by specifying the \"(I\" option after the program name.\r\nNote that the program must be compiled with 'enter_keeps_common_data = true' set in the '$JBCRELEASEDIR/config/Config_EMULATE' file (under the appropriate emulation section).\r\nThe COMMON data area can only be passed to another jBC program.\r\nENTER can be used to execute any type of program.\r\nIf the program which contains the ENTER command (the current program) was called from a jCL program, and the program to be executed (the target program) is another jBC program, control will return to the original jCL program when the target program terminates.\r\nIf the target program is a jCL program, control will return to the command shell when the jCL program terminates.",
            "detail": "ENTER program_name\r\nENTER @variable_name"
         },
         {
            "key": "Eqs",
            "icon": 3,
            "index": 137,
            "documentation": "The EQS function tests if elements in one dynamic array are equal to the elements of another dynamic array.\r\nThis function compares each element of array 1 with the corresponding element of array 2 and returns a one if the two elements are equal in the corresponding element of a dynamic array.\r\nIt returns a zero if the two elements are not equal.\r\nIt returns zero if an element of one dynamic array does not have a corresponding element in the other dynamic array.\r\nIf either element of a corresponsing pair is null, it returns null for that element.",
            "detail": "EQS(array1, array2)"
         },
         {
            "key": "Equate",
            "icon": 14,
            "index": 138,
            "documentation": "EQUATE is used to declare a symbol equivalent to a literal, variable or simple expression.\r\nsymbol is the name of the symbol to use.\r\nCan be any name that would be valid for a variable.\r\nexpression can be a literal, a variable or a simple expression.",
            "detail": "EQU{ATE} symbol TO expression"
         },
         {
            "key": "Ereplace",
            "icon": 3,
            "index": 139,
            "documentation": "The EREPLACE function replaces a substring in an expression with another substring.\r\noccurrence specifies the number of occurrences of substring to replace.\r\nTo replace all occurrences, specify occurrence as a number less than 1.\r\nbegin specifies the first occurrence to replace.\r\nIf begin is omitted or less than one, it defaults to one.\r\nIf substring is an empty string, replacement is prefixed to expression.\r\nIf replacement is an empty string, it removes all occurrences of substring.\r\nIf expression evaluates to null, it returns null.\r\nIf substring, replacement, occurrence, or begin evaluates to null, the EREPLACE function fails and the program terminates with a run-time error message.\r\nThe EREPLACE function behaves like the CHANGE function except when substring evaluates to an empty string.",
            "detail": "EREPLACE(expression, substring, replacement [, occurrence [, begin]])"
         },
         {
            "key": "Execute",
            "icon": 14,
            "index": 140,
            "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX/Windows program, including another jBC program or a jBASE command.\r\nThe expression to be EXECUTEd can be formed from any jBASE construct.\r\nThe system will not verify that the command exists before executing it.\r\nThe command is executed by a new Bourne Shell (sh) by default.\r\nThe shell type can be changed by preceding the command with a CHAR(255) (or equivalently, @IM) concatenated with either \"k\", \"c\", or \"s\" to signify the Korn shell, C shell or Bourne Shell.\r\nVariables used to pass data to the executed program should have been assigned a value before they are used.\r\nAny variable name may be used to receive data.\r\n\r\nCAPTURING variable\r\nThe capturing clause will capture any output that the executing program would normally send to the terminal screen and place it in the variable specified. Every newline normally sent to the terminal is replaced with a field mark in the variable.\r\nRETURNING variable or SETTING variable\r\nThe returning and setting clauses are identical. Both clauses will capture the output associated with any error messages the executing program issues. The first field of the variable will be set to the exit code of the program.\r\nPASSLIST variable\r\nThe PASSLIST clause allows jBASE programs to exchange lists or dynamic arrays between them. The variable should contain the list that the program wishes to pass to the jBASE program it is executing. The program to be executed should be able to process lists, otherwise the list will just be ignored. If the variable name is not specified then the clause will pass the default select list to the executing program.\r\nRTNLIST variable\r\nIf the program executed sets up a list then the RTNLIST clause may be used to place that list into a specified variable. If the variable is omitted then the list is placed in the default list variable.\r\nPASSDATA variable\r\nThe data in the specified variable is passed to another jBC program. The executing jBC program should retrieve the data using the COLLECTDATA statement.\r\nRTNDATA variable\r\nThe RTNDATA statement returns any data passed from an executing jBC program in the specified variable. The executing jBC program should use the RTNDATA statement to pass data back to the calling program.\r\nThe clauses may be specified in any order within the statement but only one of each clause may exist.",
            "detail": "EXECUTE expression {CAPTURING variable} {RETURNING|SETTING variable}\r\n{PASSLIST expression} {RTNLIST {variable}}\r\n{PASSDATA variable} {RTNDATA variable}"
         },
         {
            "key": "Exit",
            "icon": 14,
            "index": 141,
            "documentation": "The EXIT statement is used to halt the execution of a program and return a numeric exit code to the parent process.\r\nFor compatibility with older versions of the language the EXIT statement may be used without an expression. In this case it is synonymous with the BREAK statement.\r\nAny expression provided must be parenthesized and must evaluate to a numeric result.\r\nThe numeric result is used as the UNIX or Windows exit code, which is returned to the parent process by the C function exit().\r\nIf the expression does not evaluate to a numeric then the program will enter the debugger with a suitable error message.",
            "detail": "EXIT (expression)\r\nEXIT"
         },
         {
            "key": "Exp",
            "icon": 3,
            "index": 142,
            "documentation": "The EXP function returns the mathematical constant e to the specified power.\r\nThe expression may consist of any form of jBC expression but should evaluate to a numeric argument or a runtime error will occur and the program will enter the debugger.\r\nThe function will return a value that is accurate to as many decimal places as are specified by the PRECISION of the program.",
            "detail": "EXP(expression)"
         },
         {
            "key": "Extract",
            "icon": 3,
            "index": 143,
            "documentation": "The EXTRACT function is an alternative method of accessing values in a dynamic array.\r\nexpression1 specifies the dynamic array to work with and will normally be a previously assigned variable.\r\nexpressions 2 through 4 should all return a numeric value or a runtime error will occur and the program will enter the debugger.\r\nexpression2 specifies the field to extract,\r\nexpression3 the value to extract and expression4 the sub-value to extract.",
            "detail": "EXTRACT(expression1, expression2 {, expression3 {, expression4}})"
         },
         {
            "key": "Fadd",
            "icon": 3,
            "index": 144,
            "documentation": "The FADD function performs the floating point addition of two numeric values.\r\nBoth expression1 and expression 2 must evaluate to non-null numeric values.\r\nIf either of the arguments is not numeric, a runtime 'non-numeric' error will occur.",
            "detail": "FADD(expression1, expression2)"
         },
         {
            "key": "Fdiv",
            "icon": 3,
            "index": 145,
            "documentation": "The FDIV function performs the floating point division of two numeric values.\r\nBoth expression1 and expression 2 must evaluate to non-null numeric values.\r\nIf either of the arguments evaluates to null then a run time 'non-numeric' error will occur.\r\nIf the second argument evaluates to zero then a run time 'divide by zero' error will occur.\r\nThe calculation is not subject to the PRECISION setting.",
            "detail": "FDIV(expression1, expression2)"
         },
         {
            "key": "Field",
            "icon": 3,
            "index": 146,
            "documentation": "The FIELD function will return a multi-character delimited field from within a string.\r\nstring specifies the string from which the field(s) are to be extracted.\r\ndelimiter specifies the character or characters that delimit the fields within the dynamic array.\r\noccurrence should evaluate to an integer of value 1 or higher.\r\n\tIt specifies the delimiter used as the starting point for the extraction.\r\nextractCount is an integer that specifies the number of fields to extract.\r\n\tIf omitted, 1 is assumed.\r\nIf the emulation option 'jbase_field' is set, then the field delimiter may consist of more than a single character, allowing fields to be delimited by complex codes.\r\nIf extractCount is greater than 1 then only the first character of  delimiter is used, regardless of the setting of jbase_field.",
            "detail": "FIELD(string, delimiter, occurrence{, extractCount})"
         },
         {
            "key": "Fields",
            "icon": 3,
            "index": 147,
            "documentation": "The FIELDS function is an extension of the FIELD function.\r\nIt returns a dynamic array of multi-character delimited fields from a dynamic array of strings.\r\nDynArr should evaluate to a dynamic array.\r\nDelimiter specifies the character or characters that delimit the fields within the dynamic array.\r\nOccurrence should evaluate to an integer of value 1 or higher.\r\n\tIt specifies the delimiter used as the starting point for the extraction.\r\nExtractCount is an integer that specifies the number of fields to extract.\r\n\tIf omitted, 1 is assumed.\r\nIf the emulation option 'jbase_field' is set, then the field delimiter may consist of more than a single character, allowing fields to be delimited by complex codes.\r\nIf extractCount is greater than 1 then only the first character of  delimiter is used, regardless of the setting of jbase_field.",
            "detail": "FIELDS(DynArr, Delimiter, Occurrence{, ExtractCount})"
         },
         {
            "key": "Fileinfo",
            "icon": 3,
            "index": 148,
            "documentation": "The FILEINFO function returns information about a specified file variable.\r\nThis function is currently limited to return values to determine if the file variable is a valid file descriptor variable",
            "detail": "FILEINFO(file.variable, key)"
         },
         {
            "key": "Filelock",
            "icon": 14,
            "index": 149,
            "documentation": "When the FILELOCK statement is executed, it will attempt to take an exclusive lock on the specified file.\r\nWhen the FILELOCK statement is executed, it will attempt to take an exclusive lock on the entire file.\r\nIf there are any locks currently outstanding on the file, then the statement will block until there are no more locks on the file.\r\nThe use of the LOCKED clause allows the application to perform an unblocked operation.\r\nWhen the FILELOCK statement is blocked waiting for a lock, other processes may continue to perform database operations on that file, including the removal of record locks and also the taking of record locks.\r\nOnce the FILELOCK is taken, it will block ALL database access to the file whether or not the access involves record locks. i.e. a READ will block once a FILELOCK has been executed, as will READU, READL, WRITE, CLEARFILE and so on.\r\nThe lock continues until either the file is closed, the program terminates or a FILEUNLOCK statement is executed",
            "detail": "FILELOCK filevar {LOCKED statements} {ON ERROR statements}"
         },
         {
            "key": "Fileunlock",
            "icon": 14,
            "index": 150,
            "documentation": "FILEUNLOCK is used to release a specified file lock set by the FILELOCK statement.",
            "detail": "FILEUNLOCK filevar {ON ERROR statements}"
         },
         {
            "key": "Find",
            "icon": 14,
            "index": 151,
            "documentation": "The FIND statement allows the location of a specified string within a dynamic array.\r\nexpression1 evaluates to the string to compare every element of the dynamic array with.\r\nVar1 is the dynamic array that will be searched.\r\nThe FIND command will normally find the first occurrence of expression1 unless expression2 is specified.\r\nIf specified then expression2 will cause a specific occurrence of expression1 to be located.\r\nThe three variables Var2, Var3, Var4 are used to record the Field, Value and Sub-Value positions in which expression1 was found.\r\nIf expression1 is found in any element of Var1 then Vars 2, 3 and 4 are set to the position in which it was found and any THEN clause of the statement is executed.\r\nIf expression1 is not found within any element of the dynamic array then Vars 2, 3 and 4 are undefined and the ELSE clause of the statement is executed.\r\nThe statement may omit either the THEN clause or the ELSE clause but may not omit both.",
            "detail": "FIND expression1 IN Var1 {, expression2} SETTING Var2 {, Var3 {, Var4}} THEN | ELSE statement(s)"
         },
         {
            "key": "Findstr",
            "icon": 14,
            "index": 152,
            "documentation": "The FINDSTR statement is used to locate a string as a substring of a dynamic array element.\r\nIt is similar in operation to the FIND statement.\r\neexpression1 evaluates to the string to search every element of the dynamic array with.\r\nVar1 is the actual dynamic array that will be searched.\r\nFINDSTR will normally locate the first occurrence of expression1 unless expression2 is specified.\r\nIf specified then expression2 will cause a specific occurrence of expression1 to be located.\r\nThe three variables Var2, Var3, Var4 are used to record the Field, Value and Sub-Value positions in which expression1 was found.\r\nIf expression1 is found as a substring of any element of Var1 then Vars 2, 3 and 4 are set to the position in which it was found and the THEN clause of the statement is executed if it is present.\r\nIf expression1 is not found within any element of the dynamic array then Vars 2,3 and 4 are undefined and the ELSE clause of the statement is executed.\r\nThe statement may omit either the THEN clause or the ELSE clause but may not omit both.",
            "detail": "FINDSTR expression1 IN Var1 {, expression2} SETTING Var2 {,Var3 {, Var4}} THEN | ELSE statement(s)"
         },
         {
            "key": "Fmt",
            "icon": 3,
            "index": 153,
            "documentation": "Performs formatting of output data values for use with PRINT and CRT commands.\r\nMaskExpression -> Numeric Mask Codes: [j][n][m][Z][,][c][$][Fill Character][Length]",
            "detail": "FMT(Variable, MaskExpression)"
         },
         {
            "key": "Fmts",
            "icon": 3,
            "index": 154,
            "documentation": "Performs formatting of the elements of a dynamic array for output.\r\nEach element of the array is independently acted upon and returned as an element in a new dynamic array.\r\nformat is an expression that evaluates to a string of formatting codes. The Syntax of the format expression is:\r\n[width] [background/fill] justification [edit] [mask]\r\nThe format expression specifies the width of the output field, the placement of background or fill characters, line justification, editing specifications, and format masking.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf format evaluates to null, the FMTS function fails and the program enters the debugger.",
            "detail": "FMTS(dynamic.array, format)"
         },
         {
            "key": "Fmul",
            "icon": 3,
            "index": 155,
            "documentation": "The FMUL function performs the floating point multiplication of two numeric values.\r\nBoth expression1 and expression 2 must evaluate to non-null numeric value.\r\nIf either of the arguments evaluates to null then a run time 'non-numeric' error will occur.\r\nThe calculation is not subject to the PRECISION setting.",
            "detail": "FMUL(expression1, expression2)"
         },
         {
            "key": "Fold",
            "icon": 3,
            "index": 156,
            "documentation": "The FOLD function re-delimits a string by replacing spaces with attribute marks at positions defined by a length parameter.\r\nexpression1 evaluates a string to be re-delimited.\r\nexpression2 evaluates to a positive integer that represents the maximum number of characters between delimiters in the resultant string.\r\nThe FOLD function creates a number of sub-strings such that the length of each sub-string does not exceed the length value in expression2.\r\nSpaces are converted to attribute marks except when in enclosed in sub-strings.\r\nExtraneous spaces are removed.",
            "detail": "FOLD(expression1, expression2)"
         },
         {
            "key": "Footing",
            "icon": 14,
            "index": 157,
            "documentation": "The FOOTING statement causes all subsequent output to the terminal to be halted at the end of each output page.\r\nThe expression should evaluate to a string that will be printed at the bottom of every page of output.\r\nThe string may contain a number of special characters that are interpreted and replaced in the string before it is printed.",
            "detail": "FOOTING expression"
         },
         {
            "key": "For",
            "icon": 14,
            "index": 158,
            "documentation": "The FOR statement allows the programming of looping constructs within the program.\r\nThe loop is controlled by a counting variable and may be terminated early by expressions tested after every iteration.\r\nvar is the counting variable used to control the loop.\r\nThe first time the loop is entered var is assigned the value of expression1, which must evaluate to a numeric value.\r\nAfter every iteration of the loop var is automatically incremented by 1.\r\nexpression2 must also evaluate to a numeric value as it causes the loop to terminate when the value of var is greater than the value of this expression.\r\nexpression2 is evaluated at the start of every iteration of the loop and compared with the value of expression1.\r\nIf the STEP expression3 clause is included within the statement, var will automatically be incremented by the value of expression3 after each iteration of the loop. expression3 is evaluated at the start of each iteration. expression3 may be negative, in which case the loop will terminate when var is less than expression2.\r\nThe statement may optionally include either a WHILE or UNTIL clause (not both), which will be evaluated before each iteration of the loop.\r\nWhen the WHILE clause is specified, the loop will only continue with the next iteration if expression4 evaluates to Boolean TRUE.\r\nWhen the UNTIL clause is specified the loop will only continue with the next iteration if expression4 evaluates to Boolean FALSE.\r\nBecause expression2 and expression3 must be evaluated upon each iteration of the loop, complex expressions should only be coded here if they may change within each iteration.\r\nIf the values they yield will not change then the value of these expressions should be assigned to a variable before coding the loop statement.\r\nExpressions 3 and 4 should then be replaced with these variables.\r\nThis can offer large performance increases where complex expressions are being used.",
            "detail": "FOR var = expression1 TO expression2 {STEP expression3}\r\n\r\n{WHILE | UNTIL expression4}\r\nNEXT {var}"
         },
         {
            "key": "FormList",
            "icon": 14,
            "index": 159,
            "documentation": "The FORMLIST statement creates an active select list from a dynamic array.\r\nvariable1 specifies the dynamic array from which the active select list is to be created\r\nIf variable2 is specified then the newly created list will be placed in the variable.\r\nAlternatively, a select list number in the range 0 to 10 can be specified with listnum.\r\nIf neither variable2 nor listnum is specified then the default list variable will be assumed.",
            "detail": "FORMLIST variable1 {TO variable2 | listnum}"
         },
         {
            "key": "Fsub",
            "icon": 3,
            "index": 160,
            "documentation": "The FSUB function performs the floating point subtraction of two numeric values.\r\nBoth expression1 and expression 2 must evaluate to non-null numeric values.\r\nIf either of the arguments evaluates to null then a run time 'non-numeric' error will occur.",
            "detail": "FSUB(expression1, expression2)"
         },
         {
            "key": "Function",
            "icon": 14,
            "index": 161,
            "documentation": "Identifies a user-defined function which can be invoked by other jBC programs.\r\nArguments to the function can optionally be declared.\r\nname is the name by which the function is invoked.\r\nvariable is an expression used to pass values between the calling program and the function.\r\nThe FUNCTION statement is used to identify user-written source code functions.\r\nEach function must be coded in separate records and the record Id must match that of the Function Name, which in turn should match the reference in the calling program.\r\nThe optional comma separated variable list can be a number of expressions that pass values between the calling programs and the function.\r\nTo pass an array the variable name must be preceded by the MAT keyword.\r\nWhen a user-written function is called, the calling program must specify the same number of variables as are specified in the FUNCTION statement.\r\nAn extra 'hidden' variable is used to return a value from the user-written function.\r\nThe value to be returned can be specified within the Function by the RETURN (value) statement.\r\nIf the RETURN statement is used without a value then by default an empty string is returned.\r\nThe calling program must specify a DEFFUN or DEFB statement to describe the function to be called and the function source must be cataloged and locatable similar to subroutines.",
            "detail": "FUNCTION name {({MAT} variable, {MAT} variable...) }"
         },
         {
            "key": "Ges",
            "icon": 3,
            "index": 162,
            "documentation": "The GES function performs a comparison of corresponding elements in two dynamic arrays.\r\nIf an element from the first dynamic array is greater than or equal to the corresponding element in the second dynamic array ,then a 1 is placed in the corresponding element of the resultant dynamic array.\r\nIf an element from the first dynamic array is less than the corresponding element in the second dynamic array, then a 0 is placed in the corresponding element of the resultant dynamic array.",
            "detail": "GES(DynArr1, DynArr2)"
         },
         {
            "key": "Get",
            "icon": 14,
            "index": 163,
            "documentation": "The GET statement reads a block of data directly from a device.\r\nVar is the variable in which to place the input (from the previously open Device).\r\nIf length is specified, it limits the number of characters read from the input device.\r\nIf the optional Count option is used, it returns the number of characters actually read from the device.\r\nDevice is the file variable associated with the result from a successful OPENSEQ or OPENSER command.\r\nTermChars specifies one or more characters that will terminate input.\r\nTermChar The actual character that terminated input.\r\nTimeout is the number of seconds to wait for input.\r\nIf no input is present when the timeout period expires, the ELSE clause (if specified) is executed.\r\nThe GET statement does no pre-or post-processing of the input data stream - nor does it handle any terminal echo characteristics.\r\nIt is assumed that if this is desired the application - or device drive - will handle it.\r\nIf the length and timeout expressions are not specified, the default input length is one (1) character.\r\nIf no length is specified, but TermChars are, there is no limit to the number of characters input.\r\nThe GET syntax requires that either a THEN or ELSE clause, or both, be specified.\r\nIf the data is received without error, the THEN clause is executed.\r\nIf the data cannot be received (or a timeout occurs), the ELSE clause is executed.",
            "detail": "GET Var {,length} {SETTING Count} FROM Device {UNTIL TermChars} {RETURNING TermChar} {WAITING Timeout} THEN | ELSE statements"
         },
         {
            "key": "Getx",
            "icon": 14,
            "index": 164,
            "documentation": "The GETX statement reads a block of data (in ASCII hexadecimal format) directly from a device.\r\nVar is the variable in which to place the input (from the previously open Device).\r\nIf length is specified, it limits the number of characters read from the input device.\r\nIf the optional Count option is used, it returns the number of characters actually read from the device.\r\nDevice is the file variable associated with the result from a successful OPENSEQ or OPENSER command.\r\nTermChars specifies one or more characters that will terminate input.\r\nTermChar The actual character that terminated input.\r\nTimeout is the number of seconds to wait for input.\r\nIf no input is present when the timeout period expires, the ELSE clause (if specified) is executed.\r\nThe GETX statement does no pre-or post-processing of the input data stream - nor does it handle any terminal echo characteristics.\r\nIt is assumed that if this is desired the application - or device drive - will handle it.\r\nIf the length and timeout expressions are not specified, the default input length is one (1) character.\r\nIf no length is specified, but TermChars are, there is no limit to the number of characters input.\r\nThe GETX syntax requires that either a THEN or ELSE clause, or both, be specified.\r\nIf the data is received without error, the THEN clause is executed.\r\nIf the data cannot be received (or a timeout occurs), the ELSE clause is executed.\r\nGETX will convert all input into ASCII hexadecimal format after input.",
            "detail": "GETX Var {,length} {SETTING Count} FROM Device {UNTIL TermChars} {RETURNING TermChar} {WAITING Timeout} THEN | ELSE statements"
         },
         {
            "key": "Getcwd",
            "icon": 3,
            "index": 165,
            "documentation": "The GETCWD function allows a jBC program to determine the current working directory of the program.\r\nThis will normally be the directory from which the program was executed but may have been changed with the CHDIR function.\r\nWhen executed the Var will be set to the name of the current working directory.\r\nThe function itself returns a Boolean TRUE or FALSE value indicating whether the command was successful or not.\r\nRefer to your UNIX or Windows documentation (sh is a good place to start), for more information on the concept of the current working directory.",
            "detail": "GETCWD(Var)"
         },
         {
            "key": "Getenv",
            "icon": 3,
            "index": 166,
            "documentation": "The GETENV function allows a jBC program to determine the value of any of the environment variables associated with it.\r\nThe expression should evaluate to the name of the environment variable whose value is to be returned.\r\nThe function will then assign the value of the environment variable to variable.\r\nThe function itself returns a Boolean TRUE or FALSE value indicating the success or failure of the function.",
            "detail": "GETENV(expression, variable)"
         },
         {
            "key": "Getlist",
            "icon": 14,
            "index": 167,
            "documentation": "GETLIST allows the program to retrieve a previously stored list (perhaps created with the SAVE-LIST command), into a jBC variable.\r\nvariable1 is the variable into which the list will be read.\r\nexpression should evaluate to the name of a previously stored list to retrieve, or null.\r\nIf expression evaluates to null, the current default external select list (generated by a previous SELECT command for example) will be retrieved.\r\nIf specified, variable2 will be set to the number of elements in the list.\r\nIf the statement succeeds in retrieving the list, then the statements associated with any THEN clause will be executed.\r\nIf the statement fails to find the list, then the statements associated with any ELSE clause will be executed.\r\nThe GETLIST statement is identical in function to the READLIST statement.",
            "detail": "GETLIST expression TO variable1 {SETTING variable2} THEN|ELSE statements"
         },
         {
            "key": "Gosub",
            "icon": 14,
            "index": 168,
            "documentation": "The GOSUB statement causes execution of a local subroutine, after which execution will continue with the next line of code.\r\nThe label should refer to an existent label within the current source code.\r\nThis label denotes the start of a local subroutine.\r\nLabels can be numeric or alphanumeric but an alphanumeric label must be terminated with a colon when used to denote the start of a local subroutine.\r\nNumeric labels can be terminated with a colon but it is not mandatory.\r\nThe use of the colon in the GOSUB statement is optional.",
            "detail": "GOSUB label[:]"
         },
         {
            "key": "Goto",
            "icon": 14,
            "index": 169,
            "documentation": "The GOTO statement causes program execution to jump to the code at a specified label.\r\nThe label should refer to an existing label within the current source code.\r\nLabels can be numeric or alphanumeric but alphanumeric labels must be terminated with a colon.\r\nNumeric labels can be terminated with a colon but it is not mandatory.\r\nThe use of the colon in the GOTO statement is optional.\r\n\r\nThe use of the GOTO command is not recommended as it obscures the readability of code and therefore is a hindrance to maintainability.\r\nAll programs written using the GOTO construct can be written using structured statements such as LOOP and FOR.\r\nOpinions on this are divided but the consensus is that GOTO should be avoided.\r\nOne possibly acceptable use of the GOTO statement is to transfer execution to an error handler upon detection of a fatal error that will cause the program to terminate.",
            "detail": "GOTO label[:]\r\nGO TO label[:]\r\nGO label[:]"
         },
         {
            "key": "Group",
            "icon": 3,
            "index": 170,
            "documentation": "The GROUP function is equivalent to the FIELD function.\r\nExpression1 evaluates to the string containing fields to be extracted.\r\nExpression2 evaluates to the character(s) delimiting each field within Expression1.\r\nExpression3 should evaluate to a numeric value specifying the number of the first field to extract from Expression1.\r\nExpression4 evaluates to a numeric value specifying the number of fields to extract as a group.\r\nExpression2 may evaluate to more than a single character allowing fields to be delimited with complex expressions.",
            "detail": "GROUP(Expression1, Expression2, Expression3, Expression4)"
         },
         {
            "key": "Groupstore",
            "icon": 14,
            "index": 171,
            "documentation": "The GROUPSTORE statement substitutes one group of characters with another group of characters.\r\nfrom.var The string which will be inserted into the 'to.var' variable.\r\nto.var The string which will be amended.\r\nstart The starting group number in 'to.var' which will be replaced.\r\n\tIf 'start' is less than 0 , then the absolute value of 'start' is used. If 'start' is zero, then it defaults to 1.\r\n\tIf 'start' exceeds the number of groups in 'to.var' then delimiters will be added as necessary.\r\nreplace The number of groups in 'to.var' that will be replaced.\r\n\tIf 'replace' is greater than 0, then 'replace' groups of 'from.var' will replace 'replace' groups in 'from.var'\r\n\tIf 'replace' is 0 , then all of 'from.var' will be inserted.\r\n\tIf 'replace' is less than 0, the absolute value of 'replace' is used.\r\ndelim This optionally specifies the delimiting character to use, with an attribute mark (CHAR(254)) as a default.\r\n\tIf the string is more than one character, only the first character is used.",
            "detail": "GROUPSTORE from.var IN to.var USING start,replace{,delim}"
         },
         {
            "key": "Heading",
            "icon": 14,
            "index": 172,
            "documentation": "The HEADING statement causes all subsequent output to the terminal to be halted at the end of each page.\r\nThe statement allows an expression to be evaluated and displayed at the top of each page.\r\nIf output is currently being sent to the terminal, output is paused until a carriage return is entered at the terminal - unless the N option is specified.\r\nThe expression should evaluate to a string that will be printed at the top of every page of output.\r\nThe string may contain a number of special characters that are interpreted and replaced in the string before it is printed.\r\nIf ON channel is specified then it is assumed that a PRINTER ON statement is in force and the heading will be sent to the spooler channel number assigned from a SP-ASSIGN statement.\r\nIf output is being directed to the printer (a PRINTER ON statement is in force), output sent to the terminal with the CRT statement will not be paged.\r\nIf output is being sent to the terminal, all output will be paged unless the N option is specified.\r\nThe second and subsequent HEADING statements cause a page throw in the output to the terminal or the printer. However if the HEADING expression is preceded by an attribute mark then the page throw does not occur and the new heading is used at the next 'natural' page break or PAGE statement.\r\nThe emulation option 'defer_header_output' can also be used to obtain this behavior without using the attribute mark.",
            "detail": "HEADING {ON channel} expression"
         },
         {
            "key": "Headinge",
            "icon": 14,
            "index": 173,
            "documentation": "The HEADINGE statement is the same as the HEADING statement, but causes a page eject with the HEADING statement.",
            "detail": "HEADINGE {ON channel} expression"
         },
         {
            "key": "Headingn",
            "icon": 14,
            "index": 174,
            "documentation": "The HEADINGN statement is the same as the HEADING statement, but suppresses the page eject.",
            "detail": "HEADINGN {ON channel} expression"
         },
         {
            "key": "Hush",
            "icon": 14,
            "index": 175,
            "documentation": "The HUSH statement turns the echoing of characters typed at the keyboard on or off.\r\nON suppresses input and output\r\nOFF resumes input and output\r\nINPUT suppresses input only\r\nexpression must evaluate to one of the above values\r\nHUSH acts as a toggle.\r\nIf it is used without a qualifier, it changes the current state.\r\nIt is not recommended that the statement be used to shut off output display unless it is really necessary.\r\nWhen HUSH ON is used, all output is suppressed including error messages and requests for information.",
            "detail": "HUSH ON\r\nHUSH OFF\r\nHUSH expression"
         },
         {
            "key": "Iconv",
            "icon": 3,
            "index": 176,
            "documentation": "The ICONV function converts data in external form such as dates to their internal form.\r\nexpression1 evaluates to the data that the conversion is to be performed upon.\r\nexpression2 should evaluate to the conversion code that is to be performed against the data.\r\nIf the conversion code used assumes a numeric value and a non-numeric value is passed then the original value in expression1 is returned unless the emulation option 'iconv_nonnumeric_return_null' is set.",
            "detail": "ICONV(expression1, expression2)"
         },
         {
            "key": "Iconvs",
            "icon": 3,
            "index": 177,
            "documentation": "The ICONVS function converts each element of a dynamic array to a specified internal storage format.\r\nconversion is an expression that evaluates to one or more valid conversion codes, separated by value marks (ASCII 253).\r\nEach element of dynamic.array is converted to the internal format specified by conversion and is returned in a dynamic array.\r\nIf multiple codes are used, they are applied from left to right. The first conversion code converts the value of each element of dynamic.array.\r\nThe second conversion code converts the value of each element of the output of the first conversion, and so on.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf an element of dynamic.array is null, it returns null for that element.\r\nIf conversion evaluates to null, the ICONV function fails and the program terminates with a run-time error message.\r\nThe STATUS function will reflect the result of the conversion.",
            "detail": "ICONVS(dynamic array, conversion)"
         },
         {
            "key": "If",
            "icon": 14,
            "index": 178,
            "documentation": "The IF statement is used to allow other statements to be conditionally executed.\r\nThe expression will be evaluated to a value of Boolean TRUE or FALSE.\r\nIf the expression is TRUE then the statements defined by the THEN clause will be executed (if present).\r\nIf the expression is FALSE then the statements defined by the ELSE clause are executed.\r\nThe THEN and ELSE clauses may take two different forms, being either single and multiple line statements.",
            "detail": "IF expression THEN|ELSE statements"
         },
         {
            "key": "Ifs",
            "icon": 3,
            "index": 179,
            "documentation": "The IFS function returns a dynamic array whose elements are chosen individually from one of two dynamic arrays based on the contents of a third dynamic array.\r\nIFS evaluates each element of the dynamic array.\r\nIf the element evaluates to true, it returns the corresponding element from true.array to the same element of a new dynamic array.\r\nIf the element evaluated to false, it returns the corresponding element from false.array.\r\nIf there is no corresponding element in the correct response array, it returns an empty string for that element.\r\nIf an element is null, the element evaluates to false.",
            "detail": "IFS (dynamic.array, true.array, false.array)"
         },
         {
            "key": "In",
            "icon": 14,
            "index": 180,
            "documentation": "The IN statement allows the program to receive raw data from the input device, which is normally the terminal keyboard, one character at a time.\r\nVar will be assigned the numeric value (0 - 255 decimal) of the next character received from the input device.\r\nThe statement will normally wait indefinitely (block) for a character from the keyboard.\r\nSpecifying the FOR clause to the IN statement allows the statement to stop waiting for keyboard after a specified amount of time.\r\nThe expression should evaluate to a numeric value, which will be taken as the number of deci-seconds (tenths of a second) to wait before abandoning the input.\r\nThe FOR clause must have either or both of the THEN or ELSE clauses.\r\nIf a character is received from the input device before the time-out period then Var is assigned its numeric value and the THEN clause is executed (if present).\r\nIf the input statement times out before a character is received then Var is unaltered and the ELSE clause is executed (if present).",
            "detail": "IN Var {FOR expression THEN|ELSE statements}"
         },
         {
            "key": "Include",
            "icon": 14,
            "index": 181,
            "documentation": "The INCLUDE directive inserts the program/code snippet specified into the current source code.\r\nIf the optional filename is specified the code is read from that file.",
            "detail": "INCLUDE programname\r\nINCLUDE filename programname"
         },
         {
            "key": "Index",
            "icon": 3,
            "index": 182,
            "documentation": "The INDEX function will return the position of a character or characters within another string.\r\nexpression1 evaluates to the string to be searched.\r\nexpression2 evaluates to the string or character that will be searched for within expression1.\r\nexpression3 should evaluate to a numeric value and specifies which occurrence of expression2 should be searched for within expression1.\r\nIf the specified occurrence of expression2 cannot be found in expression1 then 0 is returned.",
            "detail": "INDEX(expression1, expression2, expression3)"
         },
         {
            "key": "Indices",
            "icon": 3,
            "index": 183,
            "documentation": "The INDICES function will return information on all of the indexes associated with a specified file.\r\nThis function has a dual purpose.\r\nIn its first invocation whereby a single parameter is passed, assumed to be a file descriptor, will return a dynamic array of all the index names associated with the file.\r\nIn its second invocation two parameters are passed, the first being a file variable again and the second the name of an index.\r\nIn this case the return value from the function will be a dynamic array containing information about the specified index.",
            "detail": "INDICES(filevar { , index-name } )"
         },
         {
            "key": "Inmat",
            "icon": 3,
            "index": 184,
            "documentation": "The INMAT() function returns the number of dimensioned array elements.\r\nThe INMAT() function, used without the 'array' argument, returns the number of dimensioned array elements from the most recent MATREAD, MATREADU or MATPARSE statement.\r\nIf the number of array elements exceeds the number of elements specified in the corresponding DIM statement, the INMAT() function will return zero.\r\nWhen the INMAT() function is used with the 'array' argument, it returns the current number of elements to which 'array' was dimensioned.\r\nIn some multi-value dialects the INMAT() function is also used to return the modulo of a file after the execution of an OPEN statement.\r\nThis is inconsistent with its primary purpose and has not been implemented in jBASE.\r\nTo achieve this functionality use the IOCTL() function with the JIOCTL_COMMAND_FILESTATUS command.",
            "detail": "INMAT( {array} )"
         },
         {
            "key": "Input",
            "icon": 14,
            "index": 185,
            "documentation": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program.\r\n@(expression1, expression2) allows the screen cursor to be positioned to the specified column and row before the input prompt is sent to the screen.\r\nThe syntax for this is exactly the same as for the @() function described elsewhere.\r\nVar is the variable in which the input data is to be stored.\r\nexpression3, when specified, should evaluate to a numeric value.\r\nThis will cause input to be terminated with an automatic newline sequence after exactly this number of characters has been input.\r\nIf the _ option is specified with expression4 then the automatic newline sequence is not specified but any subsequent input characters are belled to the terminal and thrown away.\r\nexpression4, when specified, should evaluate to a sequence of 1 to 3 characters.\r\nThe first character will be printed 'expression3' times to define the field on the terminal screen.\r\nAt the end of the input, if less than 'expression3' characters were input, then the rest of the field is padded with the second character if it was supplied.\r\nIf the third character is supplied then the cursor will be positioned after the last character input rather than at the end of the input field.\r\nThe : option, when specified, suppress the echoing of the newline sequence to the terminal.\r\nThis will leave the cursor positioned after the last input character on the terminal screen.\r\nWITH expression5 allows the default input delimiter (the newline sequence) to be changed.\r\nWhen specified, expression5, should evaluate to a string of up to 256 characters, each of which may delimit the input field.\r\nIf this clause is used then the newline sequence is removed as a delimiter and must be specified explicitly within expression5 as CHAR(10).\r\nThe FOR clause allows the INPUT statement to time out after a specified waiting period instead of blocking as normal.\r\nExpression6 should evaluate to a numeric value, which will be taken as the number of deci-seconds (tenths of a second) to wait before timing out.\r\nThe time-out value is used as the time between each keystroke and should a time-out occur,\r\nVar will hold the characters that were input until the time-out.\r\nThe FOR clause requires either or both of the THEN and ELSE clauses.\r\nIf no time-out occurs the THEN clause is taken.\r\nIf a time-out does occur the ELSE clause is taken.",
            "detail": "INPUT {@(expression1{, expression2 )}{:} Var{{, expression3}, expression4} {:}{_} {WITH expression5} {FOR expression6 THEN|ELSE statements}"
         },
         {
            "key": "Inputclear",
            "icon": 14,
            "index": 186,
            "documentation": "The INPUTCLEAR statement clears the type-ahead buffer.\r\nINPUTCLEAR only clears the type-ahead buffer.\r\nIt does not clear data stacked with the DATA statement.\r\nThe INPUTCLEAR statement is synonymous with CLEARINPUT.",
            "detail": "INPUTCLEAR"
         },
         {
            "key": "Inputnull",
            "icon": 14,
            "index": 187,
            "documentation": "The INPUTNULL statement allows the definition of a character that will allow a null input to be seen by the INPUT@ statement.\r\nThe expression should evaluate to a single character.\r\nSubsequently, any INPUT@ statement that sees only this character input before the new-line sequence will NULL the variable in which input is being stored.\r\nIf expression evaluates to the NULL string \" then the default character of _ is used to define a NULL input sequence.\r\nThe INPUT statement does not default to accepting the _ character as a NULL input, the programmer must explicitly allow this with the statement:\r\n\tINPUTNULL \"",
            "detail": "INPUTNULL expression"
         },
         {
            "key": "Ins",
            "icon": 14,
            "index": 188,
            "documentation": "The INS statement allows the insertion of elements into a dynamic array.\r\nexpression evaluates to the element to be inserted in the dynamic array.\r\nexpression1, expression2 and expression3 should all evaluate to numeric values and specify the Field, Value and Sub-Value before which the new element is to be inserted.\r\nSpecifying a negative value to any of expressions 1 through 3 will cause the element to be appended as the last Field, Value or Sub-Value rather than at a specific position.\r\nOnly one of the expressions may be negative, otherwise the first negative value is used correctly but the others are treated as the value 1.\r\nThe statement will insert NULL Fields, Values or Sub-Values accordingly if any of the specified insertion points exceeds the number currently existing.",
            "detail": "INS expression BEFORE Var<expression1{, expression2{, expression3}}>"
         },
         {
            "key": "Insert",
            "icon": 3,
            "index": 189,
            "documentation": "INSERT is the function form of the INS statement, which should be used in preference to this function.\r\nexpression1 evaluates to a dynamic array in which to insert a new element and will normally be a variable.\r\nexpression2, expression3 and expression4 should evaluate to numeric values and specify the Field, Value and Sub-Value before which the new element will be inserted.\r\nexpression5 evaluates to the new element to be inserted in expression1.",
            "detail": "INSERT(expression1, expression2{, expression3 {, expression4 }}; expression5)"
         },
         {
            "key": "Int",
            "icon": 3,
            "index": 190,
            "documentation": "The INT function truncates a numeric value into its nearest integer form.\r\nexpression should evaluate to a numeric value.\r\nThe function will then return the integer portion of the value.\r\nThe function works by truncating the fractional part of the numeric value rather than by standard mathematical rounding techniques.\r\nTherefore INT(9.001) and INT(9.999) will both return the value 9.",
            "detail": "INT(expression)"
         },
         {
            "key": "Ioctl",
            "icon": 3,
            "index": 191,
            "documentation": "The purpose of the IOCTL function is to allow commands to be sent to the database driver for a particular file, and then to receive a reply from that same databasedriver.\r\nFilevar\tIs a variable that has had a file opened against it using the OPEN statement.\r\n\tHowever, if you want to use the default file variable, use -1 in this position.\r\nCommand\tCan be any numeric value (or variable containing a numeric).\r\n\tHowever, it is up to the database driver to support that particular command number.\r\nStatus\tProvide a jBC variable here.\r\n\tThe use of this variable depends upon the command parameter.\r\n\tThe return value is 0 for failure, or 1 for success.\r\n\tA value of -1 generally shows the command has not been recognized.",
            "detail": "IOCTL(Filevar, Command, Parameter)"
         },
         {
            "key": "Isalnum",
            "icon": 3,
            "index": 192,
            "documentation": "The ISALNUM function checks that an expression consists entirely of alphanumeric characters.\r\nexpression can return a result of any type.\r\nThe ISALNUM function will then return TRUE (1) if the expression consists of entirely alphanumeric characters.\r\nThe function will return FALSE (0) if any character in the expression is not alphanumeric.\r\nWhen the ISALNUM function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISALNUM( expression)"
         },
         {
            "key": "Isalpha",
            "icon": 3,
            "index": 193,
            "documentation": "The ISALPHA function checks that an expression consists entirely of alphabetic characters.\r\nexpression can return a result of any type.\r\nThe ISALPHA function will then return TRUE (1) if the expression consists of entirely alphabetic characters.\r\nThe function will return FALSE (0) if any character in the expression is not alphabetic.\r\nWhen the ISALPHA function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISALPHA( expression)"
         },
         {
            "key": "Iscntrl",
            "icon": 3,
            "index": 194,
            "documentation": "The ISCNTRL function checks that an expression consists entirely of control characters.\r\nexpression can return a result of any type.\r\nThe ISCNTRL function will then return TRUE (1) if the expression consists of entirely control characters.\r\nThe function will return FALSE (0) if any character in the expression is not a control character.\r\nWhen the ISCNTRL function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISCNTRL( expression)"
         },
         {
            "key": "Isdigit",
            "icon": 3,
            "index": 195,
            "documentation": "The ISDIGIT function checks that an expression consists entirely of numeric characters.\r\nexpression can return a result of any type.\r\nThe ISDIGIT function will then return TRUE (1) if the expression consists entirely of numeric characters.\r\nThe function will return FALSE (0) if any character in the expression is not numeric.\r\nWhen the ISDIGIT function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISDIGIT( expression)"
         },
         {
            "key": "Islower",
            "icon": 3,
            "index": 196,
            "documentation": "The ISLOWER function checks that an expression consists entirely of lower case characters.\r\nexpression can return a result of any type.\r\nThe ISLOWER function will then return TRUE (1) if the expression consists of entirely lower case characters.\r\nThe function will return FALSE (0) if any character in the expression is not lower case.\r\nWhen the ISLOWER function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISLOWER( expression)"
         },
         {
            "key": "Isprint",
            "icon": 3,
            "index": 197,
            "documentation": "The ISPRINT function checks that an expression consists entirely of printable characters.\r\nexpression can return a result of any type.\r\nThe ISPRINT function will then return TRUE (1) if the expression consists of entirely printable characters.\r\nThe function will return FALSE (0) if any character in the expression is not printable.\r\nWhen the ISPRINT function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISPRINT( expression)"
         },
         {
            "key": "Isspace",
            "icon": 3,
            "index": 198,
            "documentation": "The ISSPACE function checks that an expression consists entirely of space characters.\r\nexpression can return a result of any type.\r\nThe ISSPACE function will then return TRUE (1) if the expression consists of entirely space type characters.\r\nThe function will return FALSE (0) if any character in the expression is not a space.\r\nWhen the ISSPACE function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISSPACE( expression)"
         },
         {
            "key": "Isupper",
            "icon": 3,
            "index": 199,
            "documentation": "The ISUPPER function checks that an expression consists entirely of upper case characters.\r\nexpression can return a result of any type.\r\nThe ISUPPER function will then return TRUE (1) if the expression consists of entirely upper case characters.\r\nThe function will return FALSE (0) if any character in the expression is not upper case.\r\nWhen the ISUPPER function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
            "detail": "ISUPPER( expression)"
         },
         {
            "key": "Itype",
            "icon": 3,
            "index": 200,
            "documentation": "The ITYPE function is used to return the value resulting from the evaluation of an I-type expression in a jBASE file dictionary.\r\ni.type is an expression evaluating to the contents of an existing I-descriptor.\r\nIf i.type evaluates to null, the ITYPE function fails and the program terminates with a run-time error message.\r\nSet @FILENAME to the name of the file before ITYPE execution.",
            "detail": "ITYPE(i.type)"
         },
         {
            "key": "Jbasecoredump",
            "icon": 3,
            "index": 201,
            "documentation": "The JBASECOREDUMP function is a diagnostic tool for applications that allows a portion of the application to be dumped to an external file for later analysis.\r\nThe first expression provides the name of the operating system file to output the core dump to.\r\nYou can supply \"\" instead of a file name and jBASE allocates a filename of:\r\n\t/JBASECOREDUMP_nnnn_mmmmm\r\nwhere nnn is the port number and mmmmmm is the process id.\r\nThe second expression is not used at present.\r\nFuture versions will allow extra information to be selectively dumped.\r\nA null string is always returned from the function.",
            "detail": "JBASECOREDUMP(expression1, expression2)"
         },
         {
            "key": "Jbasethreadcreate",
            "icon": 3,
            "index": 202,
            "documentation": "The JBASETHREADCreate function starts a new thread from the current process.\r\nProgramName\tName of program to execute\r\nArguments\tCommand line arguments\r\nReserved\tThis internal string parameter is required and must always be set to \"\" (null)\r\nHandle\tThis variable will contain the returned thread handle",
            "detail": "JBASETHREADCreate(ProgramName, Arguments, Reserved, Handle)"
         },
         {
            "key": "Jbasethreadstatus",
            "icon": 3,
            "index": 203,
            "documentation": "The JBASETHREADStatus function returns the status of all running threads.\r\nThreadList\tA list of all active thread handles in this process, with one attribute per thread.",
            "detail": "JBASETHREADStatus(ThreadList)"
         },
         {
            "key": "Jqlcompile",
            "icon": 3,
            "index": 204,
            "documentation": "The JQLCOMPILE function compiles a jQL statement.\r\nStatement: is the variable, which will receive the compiled statement, used by a majority of functions to execute and work on the result set etc.\r\nCommand: is the actual jQL query that you want to compile (such as SELECT or something similar).\r\nUse RETRIEVE to obtain data records as the verb rather than an existing jQL verb.\r\nThis will ensure that the right options are set internally.\r\nIn addition, use any word that is not a jQL reserved word as the verb and it will work in the same way as RETRIEVE, implement a PLOT command that passes the entire command line into JQLCOMPILE and the results will be the same as if the first word were replaced with RETRIEVE.\r\nOption: you must specify JQLOPT_USE_SELECT to supply a select list to the JQLEXECUTE function; the compile builds a different execution plan if using select lists.\r\nMessages: If the statement fails to compile, this dynamic array is in the STOP format, therefore STOP messages can be programmed and printed.\r\nProvides a history of compilation for troubleshooting purposes;\r\nReturns -1 if there is a problem found in the statement and 0 for no problem",
            "detail": "JQLCOMPILE(Statement, Command, Options, Messages)"
         },
         {
            "key": "Jqlexecute",
            "icon": 3,
            "index": 205,
            "documentation": "The JQLEXECUTE statement executes a compiled jQL statement.\r\nStatement\tis the valid result of a call to a JQLCOMPILE statement\r\nSelectVar\tis a valid select list used to limit the statement to a predefined set of items.-",
            "detail": "JQLEXECUTE(Statement, SelectVar)"
         },
         {
            "key": "Jqlfetch",
            "icon": 3,
            "index": 206,
            "documentation": "The JQLFETCH statement fetches the next result in a compiled jQL statement.\r\nStatement: is the result of a valid call to a JQLCOMPILE statement, followed by a valid call to a  JQLEXECUTE statement.\r\nControlVar: will receive the ‘control break’ elements of any query.\r\nDataVar: will receive the actual screen data on a LIST statement for instance.\r\nThe format is one attribute per column.\r\nApplies Attribute 7 Conversions (or attribute 3 in Prime-style DICTS) to the data.\r\nIf the property STMT_PROPERTY_FORMAT is set then each attribute is also formatted according to the width and justification of the attribute definition and any override caused by the use of FMT, of DISPLAY.LIKE on the command line\r\nNOTE that column headers may also affect the formatting for that column.\r\nThis function is called until there is no more output (multiple).",
            "detail": "JQLFETCH(Statement, ControlVar, DataVar)"
         },
         {
            "key": "Jqlgetproperty",
            "icon": 3,
            "index": 207,
            "documentation": "The JQLGETPROPERTY statement gets the value of a specified property from a compiled jQL statement.\r\nPropertyValue\treceives the requested property value from the system or '' if the property is not set.\r\nStatement\tis the result of a valid JQLCOMPILE statement.\r\nColumn\tspecifies that you want the value of the property for a specific column (otherwise 0 for the whole statement).\r\nPropertyName\trefers to the equated values defined by including the file JQLINTERFACE.h.\r\n\tThis function returns -1 if there is a problem with the parameters or the programmer.\r\nThese properties answer questions such as 'Was LPTR mode asked for?' and 'How many columns are there?'\r\nNote: Properties are valid after the compile; this is the main reason for separating the compile and execute into two functions.\r\nAfter compiling, it is possible examine the properties and set properties before executing.",
            "detail": "JQLGETPROPERTY(PropertyValue, Statement, Column, PropertyName)"
         },
         {
            "key": "Jqlputproperty",
            "icon": 3,
            "index": 208,
            "documentation": "The JQLPUTPROPERTY statement sets the value of a specified property in a compiled jQL statement.\r\nPropertyValue\tis the value to which you want to set the specified property.\r\nStatement\tis the result of a valid JQLCOMPILE statement.\r\nNOTE:\tSome properties may require  JQLEXECUTE first.\r\nColumn\tholds 0 for a general property of the statement, or a column number if it is something that can be set for a specific column.\r\nPropertyName\trefers to the equated values defined by including the file JQLINTERFACE.h.\r\nThis function returns -1 if it locates a problem in the statement and zero for no problem.\r\nNote: Properties are valid after the compile; this is the main reason for separating the compile and execute into two functions. After compiling, it is possible examine the properties and set properties before executing.",
            "detail": "JQLPUTPROPERTY(PropertyValue, Statement, Column, PropertyName)"
         },
         {
            "key": "Keyin",
            "icon": 3,
            "index": 209,
            "documentation": "The KEYIN function reads a single character from the input buffer and returns it.\r\nKEYIN uses raw keyboard input, therefore all special character handling e.g. backspace is disabled.\r\nSystem special character handling such as processing of interrupts is unchanged.",
            "detail": "KEYIN()"
         },
         {
            "key": "Latin1",
            "icon": 3,
            "index": 210,
            "documentation": "The LATIN1 function converts a UTF-8 byte sequence into the binary or latin1 equivalent.\r\nThe expression is to be a UTF-8 encoded byte sequence, which is the default format when executing in International Mode.",
            "detail": "LATIN1(expression)"
         },
         {
            "key": "Left",
            "icon": 3,
            "index": 211,
            "documentation": "The LEFT function extracts a sub-string of a specified length from the beginning of a string.\r\nexpression evaluates to the string from which the sub string is extracted.\r\nlength is the number of characters that are extracted.\r\nIf length is less than 1, LEFT() returns null.\r\nThe LEFT() function is equivalent to sub-string extraction starting from the first character position, i.e. expression[1,length]",
            "detail": "LEFT(expression, length)"
         },
         {
            "key": "Len",
            "icon": 3,
            "index": 212,
            "documentation": "The LEN function returns the character length of the supplied expression.\r\nexpression can evaluate to any type and the function will convert it to a string automatically.",
            "detail": "LEN(expression)"
         },
         {
            "key": "Lens",
            "icon": 3,
            "index": 213,
            "documentation": "The LENS function returns a dynamic array of the number of bytes in each element of a dynamic array.\r\nEach element of dynamic.array must be a string value.\r\nThe characters in each element of dynamic.array are counted, with the counts returned.\r\nThe LENS function includes all blank spaces, including trailing blanks, in the calculation.\r\nIf dynamic.array evaluates to a null string, it returns zero (0).\r\nIf any element of dynamic.array is null, returns zero (0) for that element.\r\nThe LENS function when used in International Mode will return the number of characters in the specified expression rather than the number of bytes.\r\nIf the expression consists of entirely of UTF-8 characters in the ASCII range 0 – 127 then the character length of the expression will equate to the byte length.\r\nHowever, when the expression contains characters outside the ASCII range 0 – 127 then byte length and character length will differ.\r\nIf the byte length is specifically required then use the BYTELEN function in place of the LEN function.",
            "detail": "LENS(dynamic.array)"
         },
         {
            "key": "Lendp",
            "icon": 3,
            "index": 214,
            "documentation": "The LENDP function returns the display length of an expression.\r\nThe expression can evaluate to any type.\r\nThe LENDP function will evaluate each character in the expression and return the calculated display length.\r\nWhen used in International Mode the LENDP function will return the display length for the characters in the specified expression rather than the number of bytes.\r\nNOTE: Some characters, usually Japanese, Chinese, etc. will return a display length of greater than one for certain characters.\r\nSome characters, for instance control characters or null (char 0), will return a display length of 0.",
            "detail": "LENDP(expression)"
         },
         {
            "key": "Les",
            "icon": 3,
            "index": 215,
            "documentation": "The LES function determines whether elements in one dynamic array are less than or equal to the corresponding elements in another dynamic array.\r\nEach element of array1 is compared with the corresponding element of array2.\r\nIf the element from array1 is less than or equal to the element from array2, a 1 is returned in the corresponding element of a new dynamic array.\r\nIf the element from array1 is greater than the element from array2, it returns a zero (0).\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, it evaluates the undefined element as empty, and the comparison continues.\r\nIf either of a corresponding pair of elements is null, it returns null for that element. ",
            "detail": "LES(array1, array2)"
         },
         {
            "key": "Ln",
            "icon": 3,
            "index": 216,
            "documentation": "The LN function returns the value of the natural logarithm of the supplied value.\r\nThe expression should evaluate to a numeric value.\r\nThe function will then return the natural logarithm of that value.\r\nThe natural logarithm is calculated using the mathematical constant e as a number base.",
            "detail": "LN(expression)"
         },
         {
            "key": "Localdate",
            "icon": 3,
            "index": 217,
            "documentation": "The LOCALDATE function returns an internal date using the specified Timestamp and TimeZone combination.\r\nThe LOCALDATE function uses the specified Timestamp and adjusts the value by the specified TimeZone to return the date value in internal date format.",
            "detail": "LOCALDATE(Timestamp, TimeZone)"
         },
         {
            "key": "Localtime",
            "icon": 3,
            "index": 218,
            "documentation": "The LOCALTIME function returns an internal time using the specified Timestamp and TimeZone combination.\r\nThe LOCALTIME function uses the specified Timestamp and adjusts the value by the specified TimeZone to return the time value in internal time format.",
            "detail": "LOCALTIME(Timestamp, TimeZone)"
         },
         {
            "key": "Locate",
            "icon": 14,
            "index": 219,
            "documentation": "The LOCATE statement finds the position of an element within a specified dimension of a dynamic array.\r\nexpression1 evaluates to the string that will be searched for in expression2.\r\nexpression2 evaluates to the dynamic array within which expression1 will be searched for.\r\nexpression3 and expression4, when specified, cause a value or subvalue search respectively.\r\nexpression5 indicates the field, value or subvalue from which the search will begin.\r\nBY expression6 causes the search to expect the elements to be arranged in a specific order, which can considerably improve the performance of some searches.\r\nThe available string values for expression6 are:\r\nAL Values are in ascending alphanumeric order\r\nAR Values are in right justified, then ascending order\r\nAN Values are in ascending numeric order\r\nDL Values are in descending alphanumeric order\r\nDR Values are in right justified, then descending order\r\nDN Values are in descending numeric order\r\nVar will be set to the position of the Field, Value or Sub-Value in which expression1 was found if indeed, it was found.\r\nIf it was not found and expression6 was not specified then Var will be set to one position past the end of the searched dimension.\r\nIf expression6 did specify the order of the elements then Var will be set to the position before which the element should be inserted to retain the specified order.\r\nThe statement must include one of or both of the THEN and ELSE clauses.\r\nIf expression1 is found in an element of the dynamic array the statements defined by the THEN clause are executed.\r\nIf expression1 is not found in an element of the dynamic array the statements defined by the ELSE clause are executed.",
            "detail": "LOCATE expression1 IN expression2{<expression3{,expression4}>}, {,expression5} {BY expression6} SETTING Var THEN|ELSE statement(s)"
         },
         {
            "key": "Locate",
            "icon": 3,
            "index": 220,
            "documentation": "The LOCATE 'function' is the equivalent of the LOCATE statement in its traditional Pick format",
            "detail": "LOCATE(expression1, expression2{,expression3{,expression4}}; Var; expression6) THEN|ELSE statements"
         },
         {
            "key": "Lock",
            "icon": 14,
            "index": 221,
            "documentation": "The LOCK statement will attempt to set an execution lock, thus requiring any other jBC program which respects that lock to wait until this program has released it.\r\nThe expression should evaluate to a numeric value between 0 and 255 (63 in R83 import mode).\r\nThe statement will execute the THEN clause (if defined) providing the lock could be taken.\r\nIf the LOCK is already held by another program and an ELSE clause was provided then the statements defined by the ELSE clause are executed.\r\nIf no ELSE clause was provided with the statement then it will block (hang) until the lock has been released by the other program.\r\nIf the program was compiled with the environment variable JBCEMULATE set to r83, the number of execution locks is limited to 64.\r\nIf an execution lock greater than this number is specified, the actual lock taken is the specified number modulo 64.\r\nWarning! Issuing a RELEASE statement with no arguments will release all execution locks that were set in the current program.",
            "detail": "LOCK expression {THEN|ELSE statements}"
         },
         {
            "key": "Loop",
            "icon": 14,
            "index": 222,
            "documentation": "The LOOP construct allows the programmer to specify loops with multiple exit conditions.\r\nstatements1 and statements2 consist of any number of standard statements include the LOOP statement itself, thus allowing nested loops.\r\nstatements1 will always be executed at least once, after which the WHILE or UNTIL clause is evaluated.\r\nexpression is tested for Boolean TRUE/FALSE by either the WHILE clause or the UNTIL clause.\r\nWhen tested by the WHILE clause, statements2 will only be executed if expression is Boolean TRUE.\r\nWhen tested by the UNTIL clause, statements2 will only be executed if the expression evaluates to Boolean FALSE.\r\nREPEAT causes the loop to start again with the first statement following the LOOP statement.",
            "detail": "LOOP statements1 WHILE|UNTIL expression DO statements2 REPEAT"
         },
         {
            "key": "Lowcase",
            "icon": 3,
            "index": 223,
            "documentation": "The LOWCASE function converts all uppercase characters in an expression to lowercase characters. Equivalent to DOWNCASE().\r\nexpression in a string containing some alphabetic characters.\r\nNon-alphabetic characters are ignored.",
            "detail": "LOWCASE(expression)"
         },
         {
            "key": "Lower",
            "icon": 3,
            "index": 224,
            "documentation": "The LOWER function lowers system delimiters in a string to the next lowest delimiter\r\nThe expression is a string containing one or more delimiters which are lowered.",
            "detail": "LOWER(expression)"
         },
         {
            "key": "Maketimestamp",
            "icon": 3,
            "index": 225,
            "documentation": "The MAKETIMESTAMP function generates a timestamp using a combination of internal date, time and timezone.\r\nUse the MAKETIMESTAMP function to generate a timestamp using a specified time zone.\r\nThe internal date and internal time values are combined together with the time zone specification to return a UTC timestamp as  decimal seconds.",
            "detail": "MAKETIMESTAMP(InternalDate, InternalTime, Timezone)"
         },
         {
            "key": "Mat",
            "icon": 14,
            "index": 226,
            "documentation": "The MAT command is used to either assign every element in a specified array to a single value or to assign the entire contents of one array to another.\r\nArray, Array1 and Array2 are all pre-dimensioned arrays declared with the DIM statement.\r\nExpression can evaluate to any data type.\r\nNote that if any element of the array Array2 has not been assigned a value then a runtime error will occur.\r\nThis can be avoided by coding the statement MAT Array2 = \" after the DIM statement.",
            "detail": "MAT Array = expression\r\nMAT Array1 = MAT Array2"
         },
         {
            "key": "Matbuild",
            "icon": 14,
            "index": 227,
            "documentation": "The MATBUILD statement is used to create a dynamic array out of a dimensioned array.\r\nvariable is the jBC variable into which the created dynamic array will be stored.\r\nArray is a previously dimensioned and assigned matrix from which the dynamic array will be created. expression1 and expression2 should evaluate to numeric integers. expression1 specifies which element of the array the extraction will start with; expression2 specifies which element of the array the extraction will end with (inclusive).\r\nBy default, each array element is separated in the dynamic array by a field mark.\r\nBy specifying expression3, the separator character can be changed.\r\nIf expression3 evaluates to more than a single character, only the first character of the string is used.\r\nWhen specifying start and end positions with multi-dimensional arrays, it is necessary to expand the matrix into its total number of variables to calculate the correct element number. See the information about dimensioned arrays earlier in this chapter for detailed instructions on calculating element numbers.",
            "detail": "MATBUILD variable FROM array{, expression1{, expression2}} {USING expression3}"
         },
         {
            "key": "Match",
            "icon": 14,
            "index": 228,
            "documentation": "The MATCH or MATCHES function allows pattern matching to be applied to an expression.\r\nexpression1 may evaluate to any type.\r\nexpression2 should evaluate to a valid pattern matching string as described below.\r\nexpression1 is then matched to the pattern supplied and a value of Boolean TRUE is returned if the pattern is matched.\r\nA value of Boolean FALSE is returned if the pattern is not matched.\r\nexpression2 can contain any number of patterns to match separated by value marks.\r\nThe value mark implies a logical OR of the specified patterns and the match will evaluate to Boolean TRUE if expression1 matches any of the specified patterns.",
            "detail": "expression1 MATCH expression2"
         },
         {
            "key": "Matches",
            "icon": 14,
            "index": 229,
            "documentation": "The MATCH or MATCHES function allows pattern matching to be applied to an expression.\r\nexpression1 may evaluate to any type.\r\nexpression2 should evaluate to a valid pattern matching string as described below.\r\nexpression1 is then matched to the pattern supplied and a value of Boolean TRUE is returned if the pattern is matched.\r\nA value of Boolean FALSE is returned if the pattern is not matched.\r\nexpression2 can contain any number of patterns to match separated by value marks.\r\nThe value mark implies a logical OR of the specified patterns and the match will evaluate to Boolean TRUE if expression1 matches any of the specified patterns.",
            "detail": "expression1 MATCHES expression2"
         },
         {
            "key": "Matchfield",
            "icon": 3,
            "index": 230,
            "documentation": "The MATCHFIELD function checks a string against a match pattern.\r\nSee also MATCHES for information about pattern matching.\r\nfield is an expression that evaluates to the portion of the match string to be returned.\r\nIf string matches pattern, the MATCHFIELD function returns the portion of string that matches the specified field in pattern.\r\nIf string does not match pattern, or if string or pattern evaluates to the null value, the MATCHFIELD function returns an empty string.\r\nIf field evaluates to the null value, the MATCHFIELD function fails and the program terminates with a run-time error.\r\npattern must contain specifiers to cover all characters contained in string.",
            "detail": "MATCHFIELD(string, pattern, field)"
         },
         {
            "key": "Matparse",
            "icon": 14,
            "index": 231,
            "documentation": "The MATPARSE statement is used to assign the elements of a matrix from the elements of a dynamic array.\r\narray is a previously dimensioned matrix, which will be assigned to from each element of the dynamic array. variable1 is the jBC variable from which the matrix array will be stored.\r\nexpression1 and expression2 should evaluate to numeric integers.\r\nexpression1 specifies which element of the array the assignment will start with;\r\nexpression2 specifies which element of the array the assignment will end with (inclusive).\r\nBy default, each array element in the dynamic array is assumed to be separated by a field mark.\r\nBy specifying expression3, the separator character can be changed.\r\nIf expression3 evaluates to more than a single character, only the first character of the string is used.\r\nAs assignment will stop when the contents of the dynamic array have been exhausted, it can be useful to determine the number of matrix elements that were actually assigned to.\r\nIf the SETTING clause is specified then variable2 will be set to the number of elements of the array that were assigned to.\r\nWhen specifying start and end positions with multi-dimensional arrays, it is necessary to expand the matrix into its total number of variables to calculate the correct element number.",
            "detail": "MATPARSE array{, expression1{, expression2}} FROM variable1 {USING expression3} SETTING variable2"
         },
         {
            "key": "Matread",
            "icon": 14,
            "index": 232,
            "documentation": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array.\r\narray should be a previously dimensioned array, which will be used to store the record to be read.\r\nIf specified, variable1 should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable1 is not specified then the default file is assumed.\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the record is found and can be read from the file then it is mapped into array and the THEN statements are executed (if any).\r\nIf the record cannot be read from the file for some reason then array is unchanged and the ELSE statements (if any) are executed.\r\nIf the record could not be read because another process already had a lock on the record then one of two actions is taken.\r\nIf the LOCKED clause was specified in the statement then the statements dependant on it are executed.\r\nIf no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process.\r\nIf a LOCKED clause is used and the read is successful, a lock will be set.\r\nIf the SETTING clause is specified, setvar will be set to the number of fields in the record on a successful read.\r\nIf the read fails, setvar will be assigned an Incremental File Errorcode.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128.\r\nThe record is mapped into the array using a predefined algorithm.\r\nThe record is expected to consist of a number of Field separated records, which are then assigned one at a time to each successive element of the matrix.\r\nIf there were more fields in the record than elements in the array then the final element of the array will be assigned all remaining fields.\r\nIf there were fewer fields in the record than elements in the array then remaining array elements will be assigned a null value.",
            "detail": "MATREAD array FROM {variable1,}expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} {THEN|ELSE statements}"
         },
         {
            "key": "Matreadu",
            "icon": 14,
            "index": 233,
            "documentation": "The MATREADU statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array.\r\nThe record will also be locked for update by the program.\r\narray should be a previously dimensioned array, which will be used to store the record to be read.\r\nIf specified, variable1 should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable1 is not specified then the default file is assumed (see OPEN statement).\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the record is found and can be read from the file then it is mapped into array and the THEN statements are executed (if any).\r\nIf the record cannot be read from the file for some reason then array is unchanged and the ELSE statements (if any) are executed.\r\nIf the record could not be read because another process already had a lock on the record then one of two actions is taken.\r\nIf the LOCKED clause was specified in the statement then the statements dependant on it are executed.\r\nIf no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process.\r\nIf the SETTING clause is specified, setvar will be set to the number of fields in the record on a successful read. If the read fails, setvar will be assigned an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128.\r\nThe record is mapped into the array using a predefined algorithm.\r\nThe record is expected to consist of a number of Field separated records, which are then assigned one at a time to each successive element of the matrix.\r\nIf there were more fields in the record than elements in the array then the final element of the array will be assigned all remaining fields.\r\nIf there were fewer fields in the record than elements in the array then remaining array elements will be assigned a null value.",
            "detail": "MATREADU array FROM { variable1,}expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} {THEN|ELSE statements}"
         }, 
         {
            "key": "Matwrite",
            "icon": 14,
            "index": 234,
            "documentation": "The MATWRITE statement transfers the entire contents of a dimensioned array to a specified record on disc.\r\narray should be a previously dimensioned and initialized array. \r\nf specified, variable should be a previously opened file variable (i.e. the subject of an OPEN statement).\r\nIf variable is not specified the default file variable is used. expression should evaluate to the name of the record in the file.\r\nIf the SETTING clause is specified and the write succeeds, setvar will be set to the number of attributes read into array.\r\nIf the SETTING clause is specified and the write fails, setvar will be assigned an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128.\r\nThe compiler will check that the variable specified is indeed an array and has been dimensioned before its use in the statement.",
            "detail": "MATWRITE array ON { variable,}expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Matwriteu",
            "icon": 14,
            "index": 235,
            "documentation": "The MATWRITEU statement transfers the entire contents of a dimensioned array to a specified record on file, in the same manner as the MATWRITE statement.\r\nAn existing record lock will be preserved.\r\narray should be a previously dimensioned and initialized array.\r\nIf specified, variable should be a previously opened file variable (i.e. the subject of an OPEN statement).\r\nIf variable is not specified the default file variable is used. expression should evaluate to the name of the record in the file.\r\nIf the SETTING clause is specified and the write succeeds, setvar will be set to the number of attributes read into array.\r\nIf the SETTING clause is specified and the write fails, setvar will be assigned an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128.\r\nThe compiler will check that the variable specified is indeed an array and has been dimensioned before its use in the statement.",
            "detail": "MATWRITEU array ON { variable,}expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Maximum",
            "icon": 3,
            "index": 236,
            "documentation": "The MAXIMUM function is used to return the element of a dynamic array with the highest numerical value.\r\nDynArr should evaluate to a dynamic array.\r\nNull dynamic array elements are treat as zero.\r\nNon-numeric dynamic array elements are ignored.",
            "detail": "MAXIMUM(DynArr)"
         },
         {
            "key": "Minimum",
            "icon": 3,
            "index": 237,
            "documentation": "The MINIMUM function is used to return the element of a dynamic array with the lowest numerical value.\r\nDynArr should evaluate to a dynamic array.\r\nNull dynamic array elements are treat as zero.\r\nNon-numeric dynamic array elements are ignored.",
            "detail": "MINIMUM(DynArr)"
         },
         {
            "key": "Mod",
            "icon": 3,
            "index": 238,
            "documentation": "The MOD and REM functions return the arithmetic modulo (remainder) of two numeric expressions.\r\nBoth expression1 and expression2 should evaluate to numeric expressions or a runtime error will occur.\r\nThe modulo is calculated as the remainder of expression1 divided by expression2.\r\nIf expression2 evaluates to 0, then the value of expression1 is returned.",
            "detail": "MOD(expression1, expression2)"
         },
         {
            "key": "Mods",
            "icon": 3,
            "index": 239,
            "documentation": "The MODS function creates a dynamic array of the remainder after the integer division of the corresponding elements of two dynamic arrays.\r\nThe MODS function calculates each element according to the following formula:\r\n\tXY.element = X ??(INT (X / Y) * Y)\r\nX is an element of array1 and Y is the corresponding element of array2.\r\nThe resulting element is returned in the corresponding element of a new dynamic array.\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, 0 is returned.\r\nIf an element of array2 is 0, 0 is returned.\r\nIf either of a corresponding pair of elements is null, null is returned for that element.",
            "detail": "MODS(array1, array2)"
         },
         {
            "key": "Msleep",
            "icon": 14,
            "index": 240,
            "documentation": "Allows the program to pause execution for a specified number of milliseconds.\r\nmilliseconds must be an integer which specifies the number of milliseconds to sleep.\r\nIf no parameter is supplied then a default time period of 1 millisecond is assumed.\r\nIf the debugger is invoked while a program is sleeping and then execution continued, the user will be prompted:\r\n\tContinue with SLEEP (Y/N) ?\r\nIf \"N\" is the response, the program will continue at the next statement after the MSLEEP.",
            "detail": "MSLEEP {milliseconds}"
         },
         {
            "key": "Muls",
            "icon": 3,
            "index": 241,
            "documentation": "The MULS function returns a dynamic array, the content of which is derived by multiplying the corresponding elements of two dynamic arrays passed as arguments.\r\nDynArr1 and DynArr2 represent dynamic arrays.\r\nNull elements of argument arrays are treated as zero.\r\nOtherwise, a non-numeric element in an argument array will cause a run-time error.",
            "detail": "MULS(DynArr1, DynArr2)"
         },
         {
            "key": "Neg",
            "icon": 3,
            "index": 242,
            "documentation": "The NEG function is used to invert the arithmetic value of an expression.\r\nexpression may evaluate to any numeric value.",
            "detail": "NEG(expression)"
         },
         {
            "key": "Negs",
            "icon": 3,
            "index": 243,
            "documentation": "The NEGS function is used to return the negative values of all the elements in a dynamic array.\r\nIf the value of the element is negative, the returned value is positive.\r\nIf array evaluates to null, null is returned.\r\nIf any element is null, null is returned for that element.",
            "detail": "NEGS(array)"
         },
         {
            "key": "Nes",
            "icon": 3,
            "index": 244,
            "documentation": "The NES function determines whether elements of one dynamic array are equal to the elements of another dynamic array.\r\nEach element of array1 is compared with the corresponding element of array2.\r\nIf the two elements are equal, a 0 is returned in the corresponding element of a new dynamic array.\r\nIf the two elements are not equal, a 1 is returned.\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, a 1 is returned.\r\nIf either of a corresponding pair of elements is null, null is returned for that element.",
            "detail": "NES(array1, array2)"
         },
         {
            "key": "Next",
            "icon": 14,
            "index": 245,
            "documentation": "The NEXT statement terminates a FOR loop. Control is passed back to the FOR statement and the variable is incremented or decremented.",
            "detail": "NEXT variable"
         },
         {
            "key": "Nobuf",
            "icon": 14,
            "index": 246,
            "documentation": "The NOBUF statement turns off buffering for a file previously opened for sequential processing.\r\njBASE can buffer for sequential input and output operations.\r\nThe NOBUF statement turns off this behavior and causes all writes to the file to be performed immediately.\r\nThe NOBUF statement should be used in conjunction with a successful OPENSEQ statement and before any input or output is performed on the record.\r\nIf the NOBUF operation is successful, it executes the THEN statements otherwise, executes the ELSE statements.\r\nIf file.variable is not a valid file descriptor then NOBUF statement fails and the program enters the debugger.",
            "detail": "NOBUF file.variable {THEN statements [ELSE statements] | ELSE statements}"
         },
         {
            "key": "Not",
            "icon": 3,
            "index": 247,
            "documentation": "The NOT function is used to invert the Boolean value of an expression.\r\nIt useful for explicitly testing for a false condition.\r\nexpression may evaluate to any Boolean result.\r\nThe NOT function will return Boolean TRUE if the expression returned a Boolean FALSE.\r\nIt will return Boolean FALSE of the expression returned a Boolean TRUE.\r\nThe NOT function is useful for explicitly testing for the false condition of some test and can clarify the logic of such a test.",
            "detail": "NOT(Expression)"
         },
         {
            "key": "Nots",
            "icon": 3,
            "index": 248,
            "documentation": "The NOTS function is used to return a dynamic array of the logical complements of each element of a dynamic array.\r\nIf the value of the element is true, the NOTS function returns a value of false (0) in the corresponding element of the returned array.\r\nIf the value of the element is false, the NOTS function returns a value of true (1) in the corresponding element of the returned array.r\nA numeric expression that evaluates to 0 has a logical value of false.\r\nA numeric expression that evaluates to anything else, other than the null value, is a logical true.\r\nAn empty string is logically false.\r\nAll other string expressions, including strings, which consist of an empty string, spaces, or the number 0 and spaces, are logically true.\r\nIf any element in array is null, it returns null for that element.",
            "detail": "NOTS(array)"
         },
         {
            "key": "Null",
            "icon": 14,
            "index": 249,
            "documentation": "The NULL statement performs no function but can be useful in clarifying syntax and where the language requires a statement but the programmer does not wish to perform any actions.",
            "detail": "NULL"
         },
         {
            "key": "Num",
            "icon": 3,
            "index": 250,
            "documentation": "The NUM function is used to test arguments for numeric values.\r\nexpression may evaluate to any data type.\r\nIf every character in expression is found to be numeric then NUM returns a value of Boolean TRUE.\r\nIf any character in expression is found not to be numeric then a value of Boolean FALSE is returned.\r\nNote that to execute user code migrated from older systems correctly, the NUM function will accept both a null string and the single characters \".\", \"+\", and \"-\" as being numeric\r\nThe aforementioned single characters will not be considered numeric if 'dot_not_numeric' is set to 'true' in the Config_EMULATE file.\r\nCHAR(0) is also considered numeric, therefore NUM(CHAR(0)) returns TRUE.\r\nIf running jBC in ros emulation, the \".\" , \"+\" and \"-\" characters would not be considered numeric.",
            "detail": "NUM(expression)"
         },
         {
            "key": "Nums",
            "icon": 3,
            "index": 251,
            "documentation": "The NUMS function is used to determine whether the elements of a dynamic array are numeric.\r\nIf an element is numeric, a numeric string, or an empty string, it evaluates to true, and returns a value of 1 to the corresponding element in a new dynamic array.\r\nIf the element is a nonnumeric string, it evaluates to false, and returns a value of 0.\r\nThe NUMS of a numeric element with a decimal point ( . ) evaluates to true; the NUMS of a numeric element with a comma ( , ) or dollar sign ( $ ) evaluates to false.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf an element of dynamic.array is null, it returns null for that element.\r\nWhen using the NUMS function in International Mode, the statement will use the Unicode Standard to determine whether an expression is numeric.",
            "detail": "NUMS(dynamic.array)"
         },
         {
            "key": "Objexcallback",
            "icon": 14,
            "index": 252,
            "documentation": "The OBJEXCALLBACK statement allows communication between the subroutine and the calling OBjEX program.\r\nexpression1 and expression2 can contain any data.\r\nThey are passed back to the OBjEX program where they are defined as variants.\r\nIf the subroutine containing the OBJEXCALLBACK statement is not called from an OBjEX program (using the Call Method) then the ELSE clause will be taken.\r\nThe OBJEXCALLBACK statement is designed to allow jBC subroutines to temporarily return to the calling environment to handle exception conditions or prompt for additional information.\r\nAfter servicing this event the code should return control to the jBC program to ensure that the proper clean-up operations are eventually made.\r\nThe two parameters can be used to pass data between the jBC and OBjEX environments in both directions.\r\nThey are defined as Variants in the OBjEX environment and as normal variables in the jBC environment.",
            "detail": "OBJEXCALLBACK expression1, expression2 THEN|ELSE statements"
         },
         {
            "key": "Oconv",
            "icon": 3,
            "index": 253,
            "documentation": "The OCONV function is used to convert internal representations of data to their external form.\r\nexpression1 may evaluate to any data type but must be be relevant to the conversion code.\r\nexpression2 should evaluate to a conversion code from the list below.\r\nAlternatively, expression2 may evaluate to a user exit known to the jBC language or supplied by the user (see external interfaces documentation).\r\nOCONV will return the result of the conversion of expression1 by expression2.\r\nIt is also possible to create customized conversion codes that can be used in a jBASE application.",
            "detail": "OCONV(expression1, expression2)"
         },
         {
            "key": "Oconvs",
            "icon": 3,
            "index": 254,
            "documentation": "The OCONVS function is used to convert the elements of a dynamic array to a specified format for external output.\r\nConverts the elements to the external output format specified by conversion and returned in a dynamic array conversion must evaluate to one or more conversion codes separated by value marks (ASCII 253).\r\nIf multiple codes are used, they are applied from left to right as follows: the left-most conversion code is applied to the element, the next conversion code to the right is then applied to the result of the first conversion, and so on.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf any element of dynamic.array is null, it returns null for that element.\r\nIf conversion evaluates to null, the OCONVS function fails and the program terminates with a run-time error message.\r\nThe STATUS function reflects the result of the conversion.",
            "detail": "OCONVS(dynamic.array, conversion)"
         },
         {
            "key": "On",
            "icon": 3,
            "index": 255,
            "documentation": "The ON...GOSUB and ON...GOTO statements are used to transfer program execution to a label based upon a calculation.\r\nexpression should evaluate to an integer numeric value. Labels should be defined somewhere in the current source file.\r\nON GOTO will transfer execution to the labeled source code line in the program.\r\nON GOSUB will transfer execution to the labeled subroutine within the source code.\r\nThe value of expression is used as an index to the list of labels supplied.\r\nIf the expression evaluates to 1 then the first label will be jumped to, 2 then the second label will be used and so on.\r\nIf the program was compiled when the emulation included the setting 'generic_pick = true', then no validations are performed on the index.\r\nTherefore, if the index is out of range, this instruction will take no action and report no error.\r\nIf the program was compiled for other emulations then the index will be range checked.\r\nIf the index is found to be less than 1 it is assumed to be 1 and a warning message is issued.\r\nIf the index is found to be too big, then the last label in the list will be used to transfer execution and a warning message issued.",
            "detail": "ON expression GOTO label{, label...}\r\nON expression GOSUB label{, label...}"
         },
         {
            "key": "Open",
            "icon": 14,
            "index": 256,
            "documentation": "The OPEN statement is used to open a file or device to a descriptor variable.\r\nThe combination of expression1 and expression2 should evaluate to a valid file name of a file type that has been installed in the jBASE system.\r\nIf the file has a dictionary section and this is to be opened by the statement then this may be specified by the literal string \"DICT\" being specified in expression1.\r\nIf specified, the variable will be used to hold the descriptor for the file.\r\nIt should then be used to access the file via READ and WRITE.\r\nIf no file descriptor variable is supplied, then the file will be opened to the default file descriptor.\r\nSpecific data sections of a multi level file may specified by separating the section name from the file name by a \",\" char in expression2.\r\nIf the OPEN statement fails it will execute any statements associated with an ELSE clause.\r\nIf the OPEN is successful it will execute any statements associated with a THEN clause.\r\nNote that the syntax requires either one or both of the THEN and ELSE clauses.\r\nIf the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code.\r\nThe OPEN statement uses the environment variable JEDIFILEPATH to search for the file named.\r\nIf this is not defined then the current working directory is used, followed by the home directory of the current process.\r\nSee the documentation on environment variables for more details.\r\nThe file that is the subject of the OPEN statement can be of any type known to the jBASE system.\r\nIts type will be determined and correctly opened transparently to the application, which need not be aware of the file type.\r\nThere is no limit to the number of files that may be opened by a jBC program.",
            "detail": "OPEN {expression1,}expression2 TO {variable} {SETTING setvar} THEN|ELSE statements"
         },
         {
            "key": "Opendev",
            "icon": 14,
            "index": 257,
            "documentation": "Opens a device (or file) for sequential writing and/or reading.\r\nDevice specifies the target device or file \r\nFileVar contains the file descriptor of the file when the open was successful\r\nStatements conditional jBC statements\r\nIf the device does not exist or cannot be opened then the ELSE clause is executed.\r\nOnce open, a lock is taken on the device.\r\nIf the lock cannot be taken then the LOCKED clause is executed,if it exists, otherwise the ELSE clause is executed.\r\nThe specified device can be a regular file, pipe or special device file.\r\nLocks are only taken on regular file types.\r\nOnce open the file pointer is set to the first line of sequential data.",
            "detail": "OPENDEV Device TO FileVar { LOCKED statements } THEN | ELSE statements"
         },{
            "key": "Openindex",
            "icon": 14,
            "index": 258,
            "documentation": "The OPENINDEX statement is used to open a particular index definition for a particular file.\r\nThis index file variable can later be used with the SELECT statement.\r\nfilename should correspond to a valid file which has at least one index.\r\nindexname should correspond to an index created for the filename.\r\nindexvar is the variable that holds the descriptor for the index.\r\nIf the OPEN statement fails it will execute any statements associated with an ELSE clause.\r\nIf the OPEN is successful it will execute any statements associated with a THEN clause.\r\nNote that the syntax requires either one or both of the THEN and ELSE clauses.\r\nIf the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code.",
            "detail": "OPENINDEX filename,indexname TO indexvar {SETTING setvar} THEN|ELSE statements"
         },
         {
            "key": "Openpath",
            "icon": 14,
            "index": 259,
            "documentation": "The OPENPATH statement is used to open a file (given an absolute or relative path) to a descriptor variable within jBC.\r\nSee also the OPEN statement.\r\nExpression1 should be an absolute or relative path to the file including the name of the file to be opened.\r\nIf specified, variable will be used to hold the descriptor for the file.\r\nIt should then be used to access the file via READ and WRITE.\r\nIf no file descriptor variable is supplied, then the file will be opened to the default file descriptor.\r\nIf the OPENPATH statement fails it will execute any statements associated with an ELSE clause.\r\nIf the OPENPATH is successful it will execute any statements associated with a THEN clause.\r\nNote that the syntax requires either one or both of the THEN and ELSE clauses.\r\nIf the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code.\r\nThe path specified may be either a relative or absolute path and must include the name of the jBASE file being opened.\r\nThe file that is the subject of the OPENPATH statement can be of any type known to the jBASE system.\r\nIts type will be determined and correctly opened transparently to the application, which need not be aware of the file type.\r\nThere is no limit to the number of files that may be opened by a jBC program.",
            "detail": "OPENPATH expression1 TO {variable} {SETTING setvar} THEN|ELSE statements"
         },
         {
            "key": "Openseq",
            "icon": 14,
            "index": 260,
            "documentation": "Opens a file for sequential writing and/or reading.\r\nPath specifies the relative or absolute path of the target directory or file\r\nFile specifies additional path information of the target file\r\nFileVar contains the file descriptor of the file when the open was successful\r\nStatements conditional jBC statements\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128.\r\nIf the file does not exist or cannot be opened then the ELSE clause is executed.\r\nHowever if JBCEMULATE is set for Sequoia (use value \"seq\") emulation then OPENSEQ will create the file if it does not exist.\r\nThis behavior can also be achieved by specifying \"openseq_creates = true\" in Config_EMULATE for the emulation being used.\r\nAlternatively, the CREATE statement can be used, which eliminates the need for the 'openseq_creates = true' Config_EMULATE option.\r\nOnce open a lock is taken on the file.\r\nIf the lock cannot be taken then the LOCKED clause is executed, if it exists, otherwise the ELSE clause is executed.\r\nIf READONLY is specified then the process takes a read lock on the file otherwise a write lock is taken.\r\nThe specified file can be a regular, pipe or special device file.\r\nLocks are only taken on regular file types.\r\nOnce open the file pointer is set to the first line of sequential data.",
            "detail": "OPENSEQ Path{,File} {READONLY} TO FileVar {SETTING setvar} {ON ERROR statements} { LOCKED statements } THEN | ELSE statements"
         },
         {
            "key": "Openser",
            "icon": 14,
            "index": 261,
            "documentation": "Opens a serial device for sequential writing and/or reading.\r\nPath is the pathname of the required device.\r\nDevInfo consists of Baud, Flow and Parity codes.\r\nPIPE specifies the file is to be opened to a PIPE for reading.",
            "detail": "OPENSER Path,DevInfo| PIPE TO FileVar THEN | ELSE Statements"
         },
         {
            "key": "Ors",
            "icon": 3,
            "index": 262,
            "documentation": "The ORS function creates a dynamic array with the logical OR from the corresponding elements of two dynamic arrays.\r\nEach element of the new dynamic array is the logical OR of the corresponding elements of array1 and array2.\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, it assumes a false for the missing element.\r\nIf both corresponding elements of array1 and array2 are null, it returns null for those elements.\r\nIf one element is the null value and the other is 0 or an empty string, it returns null.\r\nIf one element is the null value and the other is any value other than 0 or an empty string, it returns true.",
            "detail": "ORS(array1, array2)"
         },
         {
            "key": "Osbread",
            "icon": 14,
            "index": 263,
            "documentation": "Reads an OS file from a file opened.\r\nVariable specifies the variable to contain the data from the read.\r\nFileVar specifies the file descriptor of the file opened (via OSOPEN).\r\nAT ByteExpr Specifies a location in the file from which to begin reading data.\r\nIf ByteExpr is 0, the read begins at the beginning of the file.\r\nLENGTH LengthExpr Specifies a length of data to read from the file, starting at ByteExpr.\r\nLengthExpr cannot be longer than the maximum string length determined by your system configuration.\r\nON ERROR Statements Conditional jBC statements to execute if a fatal error occurs (if the file is not open, or if the file is a read-only file).\r\nIf an ON ERROR clause is not specified, the program terminates under such fatal error conditions.\r\nThe jBC OSBREAD command reads data from a file starting at a specified byte location (ByteExpr) for a certain length of bytes (LengthExpr), and assigns the data to a variable.\r\nOSBREAD performs an operating system block read on a UNIX or Windows file.\r\njBC uses the ASCII 0 character (CHAR(0)) as a string-end delimiter.\r\nTherefore, ASCII 0 cannot be used in any string variable within jBC.\r\nOSBREAD converts CHAR(0) to CHAR(128) when reading a block of characters.\r\njBC begins reading from the file at the offset specified by ByteExpr.\r\nAfter successful execution of OSBREAD against a file, the file pointer remains at the next byte after the data read.\r\nReminder - The file must be opened using the OSOPEN command before using OSBREAD.",
            "detail": "OSBREAD Variable FROM FileVar AT ByteExpr LENGTH LengthExpr {ON ERROR Statements}"
         },
         {
            "key": "Osbwrite",
            "icon": 14,
            "index": 264,
            "documentation": "Writes an OS file to an file opened.\r\nVariable Specifies the variable to contain the data from the read.\r\nFileVar Specifies the file descriptor of the file opened (via OSOPEN).\r\nAT ByteExpr Specifies a location in the file from which to begin writing data.\r\nIf ByteExpr is 0, the write begins at the beginning of the file.\r\nON ERROR Statements Conditional jBC statements to execute if the OSBWRITE statement fails with a fatal error because the file is not open, an I/O error occurs, or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nThe jBC OSBWRITE command writes an expression to a OS file starting at a specified byte location.\r\nOSBWRITE immediately writes a file segment out to the UNIX or Windows file.\r\njBC begins writing to the file at the offset specified by ByteExpr.\r\nAfter successful execution of OSBWRITE, the file pointer remains at the next byte after the data is written.\r\nA length expression need not be specified as the number of bytes in Variable is written to the file.\r\nReminder - The file must first be opened using the OSOPEN command.\r\njBC uses the ASCII 0 character (CHAR(0)) as a string-end delimiter.\r\nTherefore, ASCII 0 cannot be used in any string variable within jBC.\r\nIf jBC reads a string that contains CHAR(0) characters using OSBREAD, those characters are converted to CHAR(128).\r\nOSBWRITE converts CHAR(128) back to CHAR(0) when writing a block of characters.",
            "detail": "OSBWRITE Variable ON | TO FileVar AT ByteExpr {ON ERROR Statements}"
         },
         {
            "key": "Osclose",
            "icon": 14,
            "index": 265,
            "documentation": "Closes a previously opened OS file.\r\nFileVar Specifies the file to close.\r\nON ERROR Statements Conditional jBC statements to execute if the OSCLOSE statement fails with a fatal error because the file is not open, an I/O error occurs, or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nThe jBC OSCLOSE command closes a sequential file that was opened with an OSOPEN statement.",
            "detail": "OSCLOSE FileVar {ON ERROR Statements}"
         },
         {
            "key": "Osdelete",
            "icon": 14,
            "index": 266,
            "documentation": "Deletes an OS file.\r\nexpression Specifies the full file path.\r\nIf the file resides in JEDIFILEPATH then just the file name is required.\r\nON ERROR Statements Conditional jBC statements to execute if the OSDELETE statement fails with a fatal error because the file is not open, an I/O error occurs, or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nThe jBC OSDELETE command deletes an NTFS or UNIX sequential file.\r\nThis command is intended for use on OS-type files and not jBASE hashed files.\r\nThis command should NEVER be used on Hashed files (see DELETE-FILE to remove Hashed files).",
            "detail": "OSDELETE expression {ON ERROR Statements}"
         },
         {
            "key": "Osopen",
            "icon": 14,
            "index": 267,
            "documentation": "The OSOPEN statment opens an OS file for processing.\r\nexpression Specifies the full file path.\r\nIf the file resides in JEDIFILEPATH then just the file name is required.\r\nREADONLY Directs jBASE to open the file for reading only.\r\nIf the program attempts to write to a file opened in READONLY mode, jBASE displays a runtime error message and does not update the file.\r\nFileVar Specifies the variable to be used to hold the descriptor for the file.\r\nThis can then be used to access the file via OSBREAD and OSBWRITE.\r\nIf no file descriptor variable is supplied, then the file will be opened to the default file descriptor.\r\nON ERROR Statements Conditional jBC statements to execute if the OSOPEN statement fails with a fatal error because an I/O error occurs or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nTHEN | ELSE\tIf the OSOPEN statement fails it will execute any statements associated with an ELSE clause.\r\n\tIf the OSOPEN is successful it will execute any statements associated with a THEN clause.\r\nNote that the syntax requires either one or both of the THEN and ELSE clauses.\r\nThe jBC OSOPEN command opens a sequential file which does not use CHAR(10) as the line delimiter.\r\nRead/write access mode is the default.\r\nAfter opening a sequential file with OSOPEN, use OSBREAD to read a block of data from the file or OSBWRITE to write a block of data to the file.",
            "detail": "OSOPEN expression {READONLY} {TO FileVar} {ON ERROR Statements} {THEN | ELSE} Statements {END}"
         },
         {
            "key": "Osread",
            "icon": 14,
            "index": 268,
            "documentation": "Reads an OS file.\r\nVariable Specifies the variable to contain the data from the read.\r\nexpression Specifies the full file path.\r\nIf the file resides in JEDIFILEPATH then just the file name is required.\r\nON ERROR Statements Conditional jBC statements to execute if the OSREAD statement fails with a fatal error because the file is not open, an I/O error occurs, or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nTHEN | ELSE\tIf the OSREAD statement fails it will execute any statements associated with an ELSE clause.\tIf the OSREAD is successful it will execute any statements associated with a THEN clause.\r\nNote that the syntax requires either one or both of the THEN and ELSE clauses.\r\nThe jBC OSREAD command reads an entire sequential file and assigns the contents of the file to a variable.\r\nDo not use OSREAD on large files.\r\nIf the file is too large for the program’s memory, the program aborts and a runtime error message is generated.\r\nOn large files, use OSBREAD or READSEQ.\r\njBASE uses the ASCII 0 character (CHAR(0)) as a string-end delimiter.\r\nASCII 0 cannot be used in any string variable within jBC.\r\nThis command converts CHAR(0) to CHAR(128) when reading a block of data.",
            "detail": "OSREAD Variable FROM expression {ON ERROR Statements} {THEN | ELSE} Statements {END}"
         },
         {
            "key": "Oswrite",
            "icon": 14,
            "index": 269,
            "documentation": "Writes an OS file.\r\nVariable Specifies the variable to contain the data from the read.\r\nexpression Specifies the full file path.\r\nIf the file resides in JEDIFILEPATH then just the file name is required.\r\nON ERROR Statements Conditional jBC statements to execute if the OSWRITE statement fails with a fatal error because the file is not open, an I/O error occurs, or jBASE cannot find the file.\r\nIf an ON ERROR clause is not specified and a fatal error occurs, the program terminates.\r\nThe jBC OSWRITE command writes the contents of an expression to a sequential file.\r\njBASE uses the ASCII 0 character (CHAR(0)) as a string-end delimiter.\r\nFor this reason, ASCII 0 cannot be used in any jBC string variable.\r\nIf jBC reads a string with a CHAR(0) character, and then the character is converted to CHAR(128), this command converts CHAR(128) to CHAR(0) when writing a block of characters.",
            "detail": "OSWRITE Variable ON |TO expression {ON ERROR Statements}"
         },
         {
            "key": "Out",
            "icon": 14,
            "index": 270,
            "documentation": "The OUT statement is used to send raw characters to the current output device (normally the terminal).\r\nexpression should evaluate to a numeric integer in the range 0 to 255, being the entire range of ASCII characters.\r\nThe numeric expression is first converted to the raw ASCII character specified and then sent directly to the output advice.",
            "detail": "OUT expression"
         },
         {
            "key": "Page",
            "icon": 14,
            "index": 271,
            "documentation": "Prints any FOOTING statement, throws a page and prints any heading statement on the current output device.\r\nIf expression is specified it should evaluate to a numeric integer, which will cause the page number after the page throw to be set to this value.",
            "detail": "PAGE {ON channel} {expression}"
         },
         {
            "key": "Pause",
            "icon": 14,
            "index": 272,
            "documentation": "The PAUSE statement allows processing to be suspended until an external event triggered by a WAKE statement from another process or a timeout occurs.\r\nexpression may evaluate to a timeout value, which is the maximum number of seconds to suspend the process.\r\nIf expression is omitted then the PAUSE statement will cause the process to suspend until woken by the WAKE statement.\r\nIf a timeout value is specified and the suspended process is not woken by a WAKE statement, then the process will continue once the timeout period has expired.\r\nIf a WAKE statement is executed for the process before the process executes the PAUSE statement then the PAUSE will be ignored and processing will continue until a subsequent PAUSE statement.",
            "detail": "PAUSE {expression}"
         },
         {
            "key": "Perform",
            "icon": 14,
            "index": 273,
            "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX/NT program, including another jBC program or a jBASE command.\r\nThe PERFORMed expression can be formed from any jBASE construct.\r\nThe system will not verify that the command exists before executing it.\r\nThe command is executed by a new Bourne Shell (sh) by default.\r\nThe shell type can be changed by preceding the command with a CHAR(255) (or equivalently, @IM) concatenated with either \"k\", \"c\", or \"s\" to signify the Korn shell, C shell or Bourne Shell.\r\nVariables used to pass data to the executed program should have been assigned a value before they are used.\r\nAny variable name may be used to receive data.\r\n\r\nCAPTURING variable\r\nThe capturing clause will capture any output that the executing program would normally send to the terminal screen and place it in the variable specified. Every newline normally sent to the terminal is replaced with a field mark in the variable.\r\nRETURNING variable or SETTING variable\r\nThe returning and setting clauses are identical. Both clauses will capture the output associated with any error messages the executing program issues. The first field of the variable will be set to the exit code of the program.\r\nPASSLIST variable\r\nThe PASSLIST clause allows jBASE programs to exchange lists or dynamic arrays between them. The variable should contain the list that the program wishes to pass to the jBASE program it is executing. The program to be executed should be able to process lists, otherwise the list will just be ignored. If the variable name is not specified then the clause will pass the default select list to the executing program.\r\nRTNLIST variable\r\nIf the program executed sets up a list then the RTNLIST clause may be used to place that list into a specified variable. If the variable is omitted then the list is placed in the default list variable.\r\nPASSDATA variable\r\nThe data in the specified variable is passed to another jBC program. The executing jBC program should retrieve the data using the COLLECTDATA statement.\r\nRTNDATA variable\r\nThe RTNDATA statement returns any data passed from an executing jBC program in the specified variable. The executing jBC program should use the RTNDATA statement to pass data back to the calling program.\r\nThe clauses may be specified in any order within the statement but only one of each clause may exist.",
            "detail": "PERFORM expression {CAPTURING variable} {RETURNING|SETTING variable}\r\n{PASSLIST expression} {RTNLIST {variable}}\r\n{PASSDATA variable} {RTNDATA variable}"
         },
         {
            "key": "Precision",
            "icon": 14,
            "index": 274,
            "documentation": "The PRECISION statement informs jBASE as to the number of digits of precision it uses after the decimal point in numbers.\r\ninteger should be in the range 0 to 9.\r\nIf the program contains no PRECISION statement then is it is set with a default precision of 4.\r\nIf there is one (or more) PRECISION statements then the first one encountered is taken as the PRECISION of the program.\r\nDuring the runtime of the program the precision will changed as it encounters any subsequent PRECISION statements.\r\nA PRECISION statement can be specified any number of times in a source file.\r\nOnly the most recently defined precision will be active at any one time.\r\nCalling programs and external subroutines do not have to be compiled at the same degree of precision, however, any changes to precision in a subroutine will not persist when control returns to the calling program.\r\njBASE uses the maximum degree of precision allowed on the host machine in all mathematical calculations to ensure maximum accuracy.\r\nIt then uses the defined precision to format the number.",
            "detail": "PRECISION integer"
         },
         {
            "key": "Print",
            "icon": 14,
            "index": 275,
            "documentation": "The PRINT statement sends data directly to the current output device, which will either be the terminal or the printer.\r\nChannel is the report channel number in the range 0 to 127.\r\nAn expression can evaluate to any data type.\r\nThe PRINT statement will convert the result to a string type for printing.\r\nExpressions separated by commas will be sent to the output device separated by a tab character.\r\nThe PRINT statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character.\r\nAs the expression can be any valid expression, it may have output formatting applied to it.\r\nIf a PRINTER ON statement is currently active then output will be sent to the currently assigned printer form queue, (see also SP-ASSIGN command).",
            "detail": "PRINT {ON Channel} expression {, expression...} {:}"
         },
         {
            "key": "Printer Close",
            "icon": 14,
            "index": 276,
            "documentation": "PRINTER CLOSE will act as PRINTER OFF but in addition will close all currently active spool jobs created by the active PRINTER ON statement.\r\nIf the optional ON channel_number is specified then only the print job created on that channel number will be closed.",
            "detail": "PRINTER CLOSE {ON channel_number}"
         },
         {
            "key": "Printer Off",
            "icon": 14,
            "index": 277,
            "documentation": "PRINTER OFF will cause all subsequent output from the PRINT statement to be redirected to the terminal device.",
            "detail": "PRINTER OFF"
         },
         {
            "key": "Printer On",
            "icon": 14,
            "index": 278,
            "documentation": "PRINTER ON will cause all subsequent output from the PRINT statement to be redirected to the print spooler.",
            "detail": "PRINTER ON"
         },
         {
            "key": "Printerr",
            "icon": 14,
            "index": 279,
            "documentation": "Used to print standard jBASE error messages.\r\nField 1 of the expression should evaluate to the numeric or string name of a valid error message in the jBASE error message file.\r\bIf the error message requires parameters then these can be passed to the message as subsequent fields of the expression.\r\nWhen the PRINTERR statement is used in International Mode, the error message file to be used, i.e. the default “jBASICmessages” or other as configured via the error message environment variable, will be suffixed with the current locale.\r\nFor example, if the currently configured locale is “fr_FR”, then the statement will attempt to find the specified error message record id in the “jBASICmessages_fr_FR” error message file.\r\nIf the file cannot be found then the country code will be discarded and just the language code used. i.e. the file “jBASICmessages_fr” will be used.\r\nIf this file is also not found then the error message file “jBASICmessages” will be used.\r\nThe PRINTERR statement is most useful for user defined messages that have been added to the standard set.",
            "detail": "PRINTERR expression"
         },
         {
            "key": "Procread",
            "icon": 14,
            "index": 280,
            "documentation": "Used to retrieve data passed to programs from a jCL program.\r\nvariable is a valid jBC identifier, which will be used to store the contents of the primary input buffer of the last jCL program called.\r\nIf the program was not initiated by a jCL program then the PROCREAD will fail and any statements associated with an ELSE clause will be executed.\r\nIf the program was initiated by a jCL program then the PROCREAD will succeed, the jCL primary input buffer will be assigned to variable and any statements associated with a THEN clause will be executed.\r\nIt is recommended that the use of jCL and therefore the PROCREAD statement should be not be expanded within your application and gradually replaced with more sophisticated methods such as UNIX scripts or jBC programs.",
            "detail": "PROCREAD variable THEN|ELSE statements"
         },
         {
            "key": "Procwrite",
            "icon": 14,
            "index": 281,
            "documentation": "Used to pass data back to the primary input buffer of a calling jCL program.\r\nexpression may evaluate to any valid data type.",
            "detail": "PROCWRITE expression"
         },
         {
            "key": "Program",
            "icon": 14,
            "index": 282,
            "documentation": "Performs no function other than to document the source code.\r\nProgname can be any string of characters.",
            "detail": "PROGRAM progname"
         },
         {
            "key": "Prompt",
            "icon": 14,
            "index": 283,
            "documentation": "Used to change the prompt character used by terminal input commands.\r\nexpression can evaluate to any printable string.\r\nThe entire string is used as the prompt.\r\nThe default prompt character is the question mark \"?\" character.",
            "detail": "PROMPT expression"
         },
         {
            "key": "Putenv",
            "icon": 3,
            "index": 284,
            "documentation": "Used to set environment variables for the current process.\r\nexpression should evaluate to a string of the form:\r\n\tEnvVarName=value\r\nwhere EnvVarName is the name of a valid environment variable and value is any string that makes sense to variable being set.\r\nIf PUTENV function succeeds it returns a Boolean TRUE value, if it fails it will return a Boolean FALSE value.\r\nPUTENV only sets environment variables for the current process and processes spawned (say by EXECUTE) by this process.\r\nThese variables are known as export only variables.",
            "detail": "PUTENV(expression)"
         },
         {
            "key": "Pwr",
            "icon": 3,
            "index": 285,
            "documentation": "The PWR function raises a number to the n'th power.\r\nBoth expression1 and expression2 should evaluate to numeric arguments.\r\nThe function will return the value of expression1 raised to the value of expression2.\r\nIf expression1 is negative and expression2 is not an integer then a maths library error is displayed and the function returns the value 0.\r\nThe error message displayed is:\r\n\tpow: DOMAIN error\r\nAll calculations are performed at the maximum precision supported on the host machine and truncated to the compiled precision on completion.",
            "detail": "PWR(expression1, expression2)\r\nor\r\nexpression1 ^ expression2"
         },
         {
            "key": "Quote",
            "icon": 3,
            "index": 286,
            "documentation": "The function will put double quotation mark at the beginning and end of a string.\r\nexpression may be any expression that is valid in the JBC language.",
            "detail": "QUOTE(Expression)"
         },
         {
            "key": "Raise",
            "icon": 3,
            "index": 287,
            "documentation": "The RAISE function raises system delimiters in a string to the next highest delimiter.\r\nThe expression is a string containing one or more delimiters which are raised.",
            "detail": "RAISE(Expression)"
         },
         {
            "key": "Read",
            "icon": 14,
            "index": 288,
            "documentation": "The READ statement allows a program to read a record from a previously opened file into a variable.\r\nvariable1 is the identifier into which the record will be read.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for anyIncremental File Error except error 128.\r\nIf you wish to set a lock on a record you should do so explicitly with the READU statement.\r\nAn attempt to access a 'null' item-id in a directory will take the ELSE clause, i.e. treated as 'item does not exist'.",
            "detail": "READ variable1 FROM { variable2,} expression {SETTING setvar} {ON ERROR statements} THEN|ELSE statements"
         },
         {
            "key": "Readblk",
            "icon": 14,
            "index": 289,
            "documentation": "The READBLK statement reads a block of data of a specified length from a file opened for sequential processing and assigns it to a variable.\r\nREADBLK variable FROM file.variable, blocksize {THEN statemente [ELSE statements]|ELSE statements }\r\nThe READBLK statement reads a block of data beginning at the current position in the file and continuing for blocksize bytes and assigns it to variable.\r\nThe current position is reset to just beyond the last readable byte.\r\nfile.variable specifies a file previously opened for sequential processing.\r\nIf the data can be read from the file, the THEN statements are executed; any ELSE statements are ignored.\r\nIf the file is not readable or if the end of file is encountered, the ELSE statements are executed and the THEN statements are ignored.\r\nIf the ELSE statements are executed, variable is set to an empty string.\r\nIf either file.variable or blocksize evaluates to null, the READBLK statement fails and the program enters the debugger.\r\nNOTE: A new line in UNIX files is one byte long, whereas in Windows it is two bytes long.\r\nThis means that for a file with newlines, the same READBLK statement may return a different set of data depending on the operating system the file is stored under.\r\nThe difference between the READSEQ statement and the READBLK statement is that the READBLK statement reads a block of data of a specified length, whereas the READSEQ statement reads a single line of data.\r\nWhen using the READBLK statement in International Mode, care must be taken to ensure that the input variable is handled properly subsequent to the READBLK statement.\r\nThe READBLK statement requires that a “bytecount” be specified, however when manipulating variables in International Mode, character length rather than byte lengths are usually used and hence possible confusion or program malfunction can occur.\r\nIf requiring character data convert the input variable from ‘binary/latin1’ to UTF-8 byte sequence via the UTF8  function.\r\nIt is recommended that the READBLK/WRITEBLK statements not be used when executing in International Mode.\r\nSimilar functionality can be obtained via the READSEQ/WRITESEQ statement, which can be used to read/write characters a line at a time from a file.",
            "detail": "READBLK variable FROM file.variable, blocksize {THEN statemente [ELSE statements] | ELSE statements}"
         },
         {
            "key": "Readl",
            "icon": 14,
            "index": 290,
            "documentation": "The READL statement allows a process to read a record from a previously opened file into a variable and takes a read-only shared lock on the record.\r\nIt respects all records locked with the READU statement but allows other processes using READL to share the same lock.\r\nvariable1 is the identifier into which the record will be read.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128.\r\nREADL takes a read-only shared record lock whereas READU takes an exclusive lock.\r\nWhat this basically means is that any record which is read using READL can also be read by another process using a READL.\r\nIn other words, the lock on the record is 'shared' in that no READU lock against the same record can be taken.\r\nSimilarly, if a READU takes a lock then READL will respect that lock.\r\nBy comparison, a READU takes an exclusive lock in that the one process retains control over the record.\r\nThe usage of READU is already well documented and hopefully understood.\r\nThe usage of READL allows for an application to present a record to one or more users such that its integrity is ensured, i.e. the user(s) viewing the record can be assured that 'wysiwyg' and that no updates to that record have been made whilst viewing the record.\r\nWhile it is permissible to WRITE a record that has a READL lock, the intent of READL is to permit a 'read-only' shared lock and the act of WRITEing this record would not be considered good programming practice.\r\nREAD takes no lock at all and does not respect any lock taken with READU or READL. In other words, a READ can be performed at any time and on any record regardless of any existing locks.\r\nDue to limitations on Windows platforms, the READL statement behaves the same as the READU statement, in other words they both take exclusive locks.\r\nIf the record could not be read because another process already had a READU lock on the record then one of two actions is taken.\r\nIf the LOCKED clause was specified in the statement then the statements dependant on it are executed.\r\nIf no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process.\r\nThe SYSTEM(43) function can be used to determine which port has the lock.\r\nIf the statement fails to read the record then any statements associated with the ELSE clause will be executed.\r\nIf the statement successfully reads the record then the statements associated with any THEN clause are executed.\r\nEither or both of THEN and ELSE clauses must be specified with the statement.\r\nThe lock taken by the READL statement will be released by any of the following events however, be aware that the record will not be fully released until all shared locks have been released:\r\n* The record is written to by the same program with WRITE, WRITEV or MATWRITE statements.\r\n* The record is deleted by the same program with the DELETE statement.\r\n* The record lock is released explicitly using the RELEASE statement.\r\n* The program stops normally or abnormally.\r\n* When a file is OPENed to a local file variable in a subroutine then the file is closed when the subroutine RETURNS so all locks taken on that file are released, including locks taken in a calling program.\r\nFiles that are opened to COMMON variables are not closed so the locks remain intact.",
            "detail": "READL variable1 FROM {variable2,} expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements"
         },
         {
            "key": "Readlist",
            "icon": 14,
            "index": 291,
            "documentation": "READLIST allows the program to retrieve a previously stored list (perhaps created with the SAVE-LIST command), into a jBC variable.\r\nvariable1 is the variable into which the list will be read. expression should evaluate to the name of a previously stored list to retrieve.\r\nIf specified, variable2 will be set to the number of elements in the list.\r\nIf the statement succeeds in retrieving the list, then the statements associated with any THEN clause will be executed.\r\nIf the statement fails to find the list, then the statements associated with any ELSE clause will be executed.\r\nThe READLIST statement is identical in function to the GETLIST statement.",
            "detail":"READLIST variable1 FROM expression {SETTING variable2} THEN|ELSE statements"
         },
         {
            "key": "ReadNext",
            "icon": 14,
            "index": 292,
            "documentation": "READNEXT retrieves the next element in a list variable.\r\nvariable1 is the variable into which the next element of the list will be read.\r\nvariable2 is used when the list has been retrieved externally from a SSELECT or similar jBASE command that has used an exploding sort directive.\r\nWhen specified, this variable will be set to the multi-value reference of the current element.\r\nFor example, if the SSELECT used a BY-EXP directive on field 3 of the records in a file, the list will contain each record key in the file as many times as there are multi-values in the field.\r\nEach READNEXT instance will set variable2 to the multi-value in field 3 that the element refers to.\r\nThis allows the multi-values in field 3 to be retrieved in sorted order.\r\nIf variable3 is specified with the FROM clause, the READNEXT operates on the list contained in variable3.\r\nIf variable3 is not specified, the default select list variable will be assumed.\r\nIf the SETTING clause is specified and the read (to build the next portion of the list) fails, setvar will be set to an Incremental File Error code.\r\nREADNEXT can be used as an expression returning a Boolean TRUE or FALSE value. If an element is successfully read from the list, TRUE is returned. If the list was empty, FALSE is returned.",
            "detail": "READNEXT variable1, variable2 {FROM variable3} {SETTING setvar} {THEN|ELSE statements}"
         },
         {
            "key": "ReadNext Key",
            "icon": 14,
            "index": 293,
            "documentation": "The READNEXT statement is extended in two ways.\r\nFirstly it can accept an index variable create with an OPENINDEX statement.\r\nSecondly, you can use the KEY modifier.\r\nIn this format the READNEXT KEY statement will return the actual index key.\r\nThe select used use MUST have been created with the OPENINDEX statement.\r\nYou can optionally return the associated record key and the multi-value number associated with it.",
            "detail": "READNEXT KEY index.key{,record.key{,vmcount}} {FROM select-def} THEN/ELSE"
         },
         {
            "key": "ReadPrev Key",
            "icon": 14,
            "index": 294,
               "documentation": "This statement is syntactically similar to the READNEXT KEY but it works in reverse order.\r\nThis statement is syntactically similar to the READNEXT but it works in reverse order.\r\nThere are some considerations when the direction is changed from a forward search to a backward search or vice-versa.\r\nWhen a SELECT statement is first executed a forward direction is assumed.\r\nTherefore if a SELECT is immediately followed by a READPREV, then a change of direction is assumed.\r\nDuring the READNEXT or READPREV sequence a next-key pointer is kept up to date.\r\nThis is the record key, or index key to use should a READNEXT be executed.\r\nDuring a change of direction from forward (READNEXT) to backward (READPREV) then the next record key or index key read in by the READPREV will be the one preceding the next-key pointer.\r\nWhen the select list is exhausted it will either point one before the start of the select list (if READPREVs have been executed) or one past the end of the select list (if READNEXTs have been executed).\r\nThus in the event of a change of direction the very first or very last index key or record key will be used.",
            "detail": "READPREV KEY index.key{,record.key{,vmcount}} {FROM select-def} THEN/ELSE"
         },
         {
            "key": "Readseq",
            "icon": 14,
            "index": 295,
            "documentation": "The READSEQ statement allows a program to read from a file opened for sequential access.\r\nVariable specifies the variable to contain next record from sequential file.\r\nFileVar specifies the file descriptor of the file opened for sequential access.\r\nSETTING if specified and the read fails, setvar will be set to one an Incremental File Errors code.\r\nON ERROR statements are executed upon any error condition, i.e. the READSEQ fails (this is usually used in conjuction with the SETTING clause)\r\nStatements conditional jBC statements.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Error except error 128.\r\nEach READSEQ reads a line of data from the sequentially opened file.\r\nAfter each READSEQ the file pointer moves forward to the next line of data.\r\nThe variable contains the line of data less the new line character from the sequential file.\r\nThe default buffer size for a READSEQ is 1024 bytes. This can be changed using the IOCTL() function with the JIOCTL_COMMAND_SEQ_CHANGE_RECORDSIZE Sequential File Extensions.",
            "detail": "READSEQ Variable FROM FileVar {SETTING setvar} {ON ERROR statements} THEN | ELSE statements\r\nVariable: specifies the variable to contain next record from sequential file.\r\nFileVar: specifies the file descriptor of the file opened for sequential access.\r\nSETTING: if specified and the read fails, setvar will be set to an Incremental File Error code.\r\nON ERROR: statements are executed upon any error condition, i.e. the READSEQ fails (this is usually used in conjuction with the SETTING clause)\r\nStatements: conditional jBC statements"
         },
         {
            "key": "Readt",
            "icon": 14,
            "index": 296,
            "documentation": "The READT statement is used to read from a range of tape devices 0-9.\r\nvariable is the variable that will receive any data read from the tape device.\r\nexpression should evaluate to an integer value in the range 0-9 and specifies from which tape channel to read data.\r\nIf the FROM clause is not specified the READT will assume channel 0.\r\nIf the READT fails then the statements associated with any ELSE clause will be executed. SYSTEM(0) will return the reason for the failure.",
            "detail": "READT variable {FROM expression} THEN|ELSE statements"
         },
         {
            "key": "Readu",
            "icon": 14,
            "index": 297,
            "documentation": "The READU statement allows a program to read a record from a previously opened file into a variable.\r\nIt respects record locking and locks the specified record for update.\r\nvariable1 is the identifier into which the record will be read.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified, then the default file is assumed.\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Error except error 128.",
            "detail": "READU variable1 FROM {variable2,} expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements"
         },
         {
            "key": "Readv",
            "icon": 14,
            "index": 298,
            "documentation": "The READV statement allows a program to read a specific field from a record in a previously opened file into a variable.\r\nvariable1 is the identifier into which the record will be read.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified, the default file is assumed.\r\nexpression1 should evaluate to a valid record key for the file.\r\nexpression2 should evaluate to a positive integer.\r\nIf the number is invalid or greater than the number of fields in the record, a NULL string will be assigned to variable1.\r\nIf the number is 0 then the value returned in variable1 is controlled by the readv0 emulation setting.\r\nIf a non-numeric argument is evaluated, a run time error will occur.\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Errors except error 128.",
            "detail": "READV variable1 FROM { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements} THEN|ELSE statements"
         },
         {
            "key": "Readvu",
            "icon": 14,
            "index": 299,
            "documentation": "The READVU statement allows a program to read a specific field in a record in a previously opened file into a variable.\r\nIt also respects record locking and locks the specified record for update.\r\nvariable1 is the identifier into which the record will be read.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nexpression1 should evaluate to a valid record key for the file.\r\nexpression2 should evaluate to a positive integer.\r\nIf the number is invalid or greater than the number of fields in the record, then a NULL string will be assigned to variable1.\r\nIf the number is 0 then the value returned in variable1 is controlled by the readv0 emulation setting.\r\nIf a non-numeric argument is evaluated a run time error will occur.\r\nIf the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code.\r\nIf ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Error except error 128.",
            "detail": "READVU variable1 FROM { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements"
         },
         {
            "key": "Readxml",
            "icon": 14,
            "index": 300,
            "documentation": "The READXML statement reads a record from a file using the style sheet held in DICT->@READXML to transform the data into XML format.",
            "detail": "READXML rec FROM file, id ELSE STOP 202, id"
         },
         {
            "key": "Recordlocked",
            "icon": 3,
            "index": 301,
            "documentation": "The RECORDLOCKED function can be called to ascertain the status of a record lock.\r\nfilevar is a file variable from a previously executed OPEN statement.\r\nrecordkey is an expression for the record id that will be checked.\r\nThe function returns an integer value to indicate the record lock status of the specified record id.\r\nIf the return value is negative, then the  SYSTEM(43) and STATUS function calls can be used to determine the port number of the program that holds the lock.\r\nIf -1 is returned, more than 1 port could hold the lock and so the port number returned will be the first port number found.",
            "detail": "RECORDLOCKED(filevar, recordkey)"
         },
         {
            "key": "Regexp",
            "icon": 3,
            "index": 302,
            "documentation": "The REGEXP function is a powerful function that allows pattern matching using UNIX regular expressions.\r\nREGEXP is not supported on Windows.\r\nvariable can be any type of jBC variable and is the variable upon which pattern matching will be performed.\r\nexpression should evaluate to a standard UNIX regular expression as defined in the UNIX documentation.\r\nThe function returns a numeric integer value being the first character in variable that failed to match the specified regular expression.\r\nIf a match is not found or the regular expression was invalid then the function returns 0.",
            "detail": "REGEXP(variable, expression)"
         },
         {
            "key": "Release",
            "icon": 14,
            "index": 303,
            "documentation": "The RELEASE statement explicitly releases record locks without updating the records using a WRITE or DELETE and it also clears all execution locks without issuing an UNLOCK.\r\nIf variable is specified it should be a valid file descriptor variable (i.e. it should have been the subject of an OPEN statement).\r\nIf an expression is supplied it should evaluate to the key of a record whose lock the program wishes to free.\r\nIf variable was specified, the record lock on the file described by it is released.\r\nIf variable was not specified the record lock on the file described by the default file variable is released.\r\nIf RELEASE is called without arguments then all record locks in all files that were set by the current program will be released.\r\nIt also releases all execution locks that were set in the current program with the LOCK statement.",
            "detail": "RELEASE {{variable,} expression}"
         },
         {
            "key": "Rem",
            "icon": 3,
            "index": 304,
            "documentation": "The MOD and REM functions return the arithmetic modulo (remainder) of two numeric expressions.\r\nBoth expression1 and expression2 should evaluate to numeric expressions or a runtime error will occur.\r\nThe modulo is calculated as the remainder of expression1 divided by expression2.\r\nIf expression2 evaluates to 0, then the value of expression1 is returned.",
            "detail": "REM(expression1, expression2)"
         },
         {
            "key": "Remove",
            "icon": 3,
            "index": 305,
            "documentation": "The REMOVE function will successively extract delimited strings from a dynamic array.\r\nvariable is the variable which is to receive the extracted string.\r\narray is the dynamic array from which the string is to be extracted.\r\nsetvar is set by the system during the extraction to indicate the type of delimiter found.\r\nThe first time the REMOVE statement is used with a particular array, it will extract the first delimited string and set the special \"remove pointer\" to the start of the next string (if any).\r\nThe next time REMOVE is used on the same array, the pointer will be used to retrieve the next string and so on.\r\nThe array is not altered.\r\nThe variable named in the SETTING clause is used to record the type of delimiter that was found - so that you can tell whether the REMOVE statement extracted a field, a value or a subvalue for example.\r\nDelimiters are defined as characters between xF9 and xFF only.\r\nOnce the end of the array has been reached, the string variable will not be updated and the SETTING clause will always return 0.\r\nYou can reset the \"remove pointer\" by assigning the variable to itself - for example REC = REC.",
            "detail": "REMOVE variable FROM array SETTING setvar"
         },
         {
            "key": "Repeat",
            "icon": 14,
            "index": 306,
            "documentation": "REPEAT causes the loop to start again with the first statement following the LOOP statement.",
            "detail": "REPEAT"
         },
         {
            "key": "Replace",
            "icon": 3,
            "index": 307,
            "documentation": "This is an obsolete way to assign to dynamic arrays via a function.\r\nvar is the dynamic array that the REPLACE function will use to assign expression4.\r\nUnless the same var is assigned the result of the function it will be unchanged.\r\nexpression1 specifies into which field assignment will be made and should evaluate to a numeric.\r\nexpression2 is only specified when multi-value assignment is to be done and should evaluate to a numeric.\r\nexpression3 is only specified when sub-value assignment is to be done and should evaluate to a numeric.\r\nexpression4 can evaluate to any data type and is the actual data that will be assigned to the array.\r\nThe function returns a copy of var with the specified replacement carried out.\r\nThis value may be assigned to the original var, in which case the jBC compiler will optimise the assignment.",
            "detail": "REPLACE(var, expression1{, expression2{, expression3}}; expression4)"
         },
         {
            "key": "Return",
            "icon": 14,
            "index": 308,
            "documentation": "The RETURN statement transfers program execution to the caller of a subroutine/function or to a specific label in the program.\r\nlabel must reference an existing label within the source of the program.\r\nexpression evaluates to the value that is returned by a user-written function.\r\nThe RETURN statement will transfer program execution to the statement after the GOSUB that called the current internal subroutine.\r\nIf the RETURN statement is executed in an external SUBROUTINE and there are no outstanding GOSUBs, then the program will transfer execution to the CALL'ing program.\r\nThe program will enter the debugger with an appropriate message should a RETURN be executed with no GOSUB or CALL outstanding.\r\nThe second form of the RETURN statement is used to return a value from a user-written function. ",
            "detail": "RETURN {TO label}\r\nRETURN(expression)"
         },
         {
            "key": "Rewind",
            "icon": 14,
            "index": 309,
            "documentation": "The REWIND statement will issue a rewind command to the device attached to the specified channel.\r\nexpression, if specified, should evaluate to an integer in the range 0 to 9.\r\nDefault is 0.\r\nIf the statement fails to issue the rewind then any statements associated with the ELSE clause are executed.\r\nIf the statement successfully issues the rewind command then the statements associated with any THEN clause are executed.\r\nEither or both of the THEN and ELSE clauses must be specified with the statement.\r\nIf the statement fails then the reason for failure can be determined via the value of SYSTEM(0).",
            "detail": "REWIND {ON expression} THEN|ELSE statements"
         },
         {
            "key": "Right",
            "icon": 3,
            "index": 310,
            "documentation": "The RIGHT function returns a sub-string composed of the last n characters of a specified string.\r\nexpression evaluates to the string from which the sub string is extracted.\r\nlength is the number of characters that are extracted.\r\nIf length is less than 1, RIGHT() returns null.\r\nThe RIGHT() function is equivalent to sub-string extraction for the last n characters, i.e. expression[n]",
            "detail": "RIGHT(expression, length)"
         },
         {
            "key": "Rnd",
            "icon": 3,
            "index": 311,
            "documentation": "The RND function allows the generation of random numbers by a program.\r\nexpression should evaluate to a numeric integer value or a runtime error will occur.\r\nThe absolute value of expression is used by the function (see ABS).\r\nThe highest number expression can be on Windows is PWR(2,15) - 1.\r\nThe highest number on UNIX is PWR(2,31) - 1.\r\nThe function will return a random integer number between 0 and the value of expression-1.",
            "detail": "RND(expression)"
         },
         {
            "key": "Rqm",
            "icon": 14,
            "index": 312,
            "documentation": "Allows the program to pause execution for a specified time period.\r\nSynonymous with SLEEP.\r\nexpression may evaluate to one of two forms:\r\n* Numeric in which case the statement will sleep for the specified number of seconds or fractions of a second.\r\n* \"nn:nn{:nn}\" in which case the statement will sleep until the time specified.\r\nIf expression is not supplied then a default time period of 1 second is assumed.",
            "detail": "RQM {expression}"
         },
         {
            "key": "Rtndata",
            "icon": 14,
            "index": 313,
            "documentation": "The RTNDATA statement allows a jBC program to return specific data to the RTNDATA clause of another program's EXECUTE statement.\r\nexpression may evaluate to any data type.\r\nWhen a jBC program executes another jBC program using the EXECUTE statement, it may specify a variable to pick up data in using the RTNDATA clause.\r\nThe data picked up will be that specified by the executed program using the RTNDATA statement.\r\nThe data will be discarded if the program is not executed by an EXECUTE statement in another program.",
            "detail": "RTNDATA expression"
         },
         {
            "key": "Reuse",
            "icon": 3,
            "index": 314,
            "documentation": "The REUSE() function causes the previous field, value or subvalue to be reused in place of this default value where array structures do not match.\r\nThe REUSE() function applies only to values in expressions; its effect cannot be assigned to a variable but it can be used to qualify an argument in a subroutine or function call.",
            "detail": "REUSE(dynamic.array)"
         },
         {
            "key": "Sadd",
            "icon": 3,
            "index": 315,
            "documentation": "The SADD function performs string addition of two base 10 string numbers.\r\nexpr1 and expr2 are strings consisting of numeric characters, optionally including a decimal part.\r\nThe SADD function can be used with numbers that may exceed a valid range with standard arithmetic operators.\r\nThe  PRECISION declaration has no effect on the value returned by this function.",
            "detail": "SADD(expr1, expr2)"
         },
         {
            "key": "Sdiv",
            "icon": 3,
            "index": 316,
            "documentation": "The SDIV function performs string division of two base 10 string numbers.\r\nThe result is rounded to 14 decimal places.\r\nexpr1 and expr2 are strings consisting of numeric characters, with either optionally including a decimal part.\r\nThe SDIV function can be used with numbers that may exceed a valid range with standard arithmetic operators.\r\nThe  PRECISION declaration has no effect on the value returned by this function.",
            "detail": "SDIV(expr1, expr2)"
         },
         {
            "key": "Seek",
            "icon": 14,
            "index": 317,
            "documentation": "The SEEK statement moves a file pointer by an offset specified in bytes, relative to the current position, the beginning of the file, or the end of the file.\r\nfile.variable specifies a file previously opened for sequential access.\r\noffset is the number of bytes before or after the reference position.\r\nA negative offset results in the pointer being moved before the position specified by relto.\r\nIf offset is not specified, 0 is assumed.\r\nOn Windows systems, line endings in files are denoted by the character sequence RETURN + LINEFEED rather than the single LINEFEED used in UNIX files. The value of offset should take into account this extra byte on each line in Windows file systems.\r\nIf relto is not specified, 0 is assumed.\r\nIf the pointer is moved, the THEN statements are executed and the ELSE statements are ignored.\r\nIf the THEN statements are not specified, program execution continues with the next statement.\r\nIf the file cannot be accessed or does not exist the ELSE statements are executed; any THEN statements are ignored.\r\nIf file.variable, offset, or relto evaluates to null, the SEEK statement fails and the program terminates with a run-time error message.",
            "detail": "SEEK file.variable [ , offset [ , relto] ] {THEN statements [ELSE statements] | ELSE statements}"
         },
         {
            "key": "Select",
            "icon": 14,
            "index": 319,
            "documentation": "The SELECT statement creates a select list of elements in a specified variable for use with the READNEXT statement.\r\nvariable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element.\r\nvariable1 may also be an existing list in which case the elements in the list will be selected.\r\nIf variable1 is not specified in the statement then the default file variable is assumed.\r\nIf variable2 is specified then the newly created list will be placed in the variable.\r\nAlternatively, a select list number in the range 0 to 10 can be specified with listnum.\r\nIf neither variable2 nor listnum is specified then the default list variable will be assumed.\r\nIf the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code.\r\nWhen a list is being built from record keys in a file, the list is not created immediately by scanning the file for all the record keys.\r\nInstead, only the first few keys will be extracted.\r\nWhen these keys have been taken from the list, the next few keys will be obtained and so on.\r\nThis means that the list could contain records that are written to the file after the SELECT command is started.\r\nIf a variable is used to hold the select list, then it should be unassigned or null prior to the SELECT.\r\nIf it contains a number in the range 0 to 10 then the corresponding select list number will be used to hold the list, although you can still reference the list with the variable name.\r\nWhen variable1 is a dynamic array (not a file descriptor) the result of variable2 is NOT a copy of variable1.",
            "detail": "SELECT {variable1} {TO variable2 | listnum} {SETTING setvar}"
         },
         {
            "key": "Select",
            "icon": 14,
            "index": 319,
            "documentation": "This form of the SELECT statement allows you to use the index data in conjunction with an index definition variable created with an OPENINDEX statement.\r\nThis form of the SELECT statement allows the index data to be used in conjunction with an index definition variable created with an OPENINDEX statement.\r\nThe normal 'TO select-def' can be used to perform the selection to a numbered list or a variable instead of to the default select list.\r\nThe use of the 'ATKEY index-key{,record-key{,vmcount}}' is optional and allows positioning at a specific point in the index.\r\nIn its minimal form, the index key at which to start selection is specified. As each index key may contain many record keys, it is possible to sub-specify at which record key within that index to use as the starting position\r\nFinally, as each record may be multi-valued with the same index data, it is possible to sub-position at which value mark within the record key.\r\nThe SELECT .. ATKEY statement uses raw data whereas the key-select and query-index programs assume the index specification is in external representation and pass it though any defined lookup code.",
            "detail": "SELECT indexvariable {TO select-def} {ATKEY index-key{,record-key{,vmcount}}}"
         },
         {
            "key": "Selecte",
            "icon": 14,
            "index": 320,
            "documentation": "The SELECTE statement allows the contents of select list 0 to be assigned to a list variable.\r\nlist.num is a select list number in the range 0 to 10",
            "detail": "SELECTE TO list.num"
         },
         { 
            "key": "Selectindex",
            "icon": 14,
            "index": 321,
            "documentation": "This statement will create a dynamic array of record keys based on a single selection of a single index key value.\r\nIt is more efficient to use a combination of OPENINDEX and READNEXT statements rather than the SELECTINDEX.\r\nindex-name must correspond to the name of a valid index created on the file that has been opened to the file descriptor file-var.\r\nIf index-key is specified it must correspond the the an indexed value within the index specified by index-name.\r\nIf select-var is specified it is used to hold the select list created by the SELECTINDEX statement.\r\nGiven an opened file descriptor this statement will select all the record keys in this file, sorted by the index definition 'index-name'.\r\nAn optional variable 'index-key' can be used to restrict this selection to a single index key value.\r\nThe value of 'index-key' will be the raw value of the index data - no lookup code processing will be done on this value.",
            "detail": "SELECTINDEX index-name{,index-key} FROM file-var {TO select-var}"
         },
         {
            "key": "Selectn",
            "icon": 14,
            "index": 322,
            "documentation": "The SELECTN statement creates a select list of elements in a specified list number for use with the READNEXT statement.\r\nvariable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element.\r\nvariable1 may also be an existing list in which case the elements in the list will be selected.\r\nIf variable1 is not specified in the statement then the default file variable is assumed.\r\nA select list number in the range 0 to 10 can be specified with listnum.\r\nIf listnum is not specified then the default list variable will be assumed.\r\nIf the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code.",
            "detail": "SELECTN {variable1} {TO listnum} {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Selectv",
            "icon": 14,
            "index": 323,
            "documentation": "The SELECTV statement creates a select list of elements in a specified variable for use with the READNEXT statement.\r\nvariable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element.\r\nvariable1 may also be an existing list in which case the elements in the list will be selected.\r\nIf variable1 is not specified in the statement then the default file variable is assumed.\r\nIf variable2 is specified then the newly created list will be placed in the variable.\r\nIf the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code.",
            "detail": "SELECTV {variable1} {TO variable2} {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Send",
            "icon": 14,
            "index": 324,
            "documentation": "The SEND statement sends a block of data directly to a device.\r\nThe output is an expression evaluating to a string that will be sent to the output device (specified by FileVar).\r\nIt is expected that the device has already been opened with OPENSER or OPENSEQ.\r\nThe SEND statement will append a newline sequence to the final output expression unless it is terminated with a colon.\r\nAs the expression can be any valid expression, it may have output formatting applied to it.\r\nThe SEND syntax requires that either a THEN or ELSE clause, or both, be specified.\r\nIf the data is sent without error, the THEN clause is executed.\r\nIf the data cannot be sent, the ELSE clause is executed.",
            "detail": "SEND output {:} TO FileVar THEN | ELSE statements"
         },
         {
            "key": "Sendx",
            "icon": 14,
            "index": 325,
            "documentation": "The SENDX statement sends a block of data (in hexadecimal) directly to a device.\r\nThe output is an expression evaluating to a string that will be sent to the output device (specified by FileVar).\r\nIt is expected that the device has already been opened with OPENSER or OPENSEQ.\r\nThe SENDX statement will append a newline sequence to the final output expression unless it is terminated with a colon.\r\nAs the expression can be any valid expression, it may have output formatting applied to it.\r\nThe SENDX syntax requires that either a THEN or ELSE clause, or both, be specified.\r\nIf the data is sent without error, the THEN clause is executed.\r\nIf the data cannot be sent, the ELSE clause is executed.",
            "detail": "SENDX output {:} TO FileVar THEN | ELSE statements"
         },
         {
            "key": "Sentence",
            "icon": 3,
            "index": 326,
            "documentation": "The SENTENCE function allows a program to find out the command used to invoke it and the arguments it was given.\r\nIf expression is specified it should evaluate to a positive integer value.\r\nA negative value will return a null string.\r\nA value of null will return the entire command line.\r\nAn integer value of expression will return a specific element of the command line with the command itself being returned by SENTENCE(0), the first parameter being returned by SENTENCE(1) and so on.\r\nThe command line arguments are assumed to be space separated and when the entire command line is returned they are returned as such.\r\nThe SYSTEM(1000) function will return the command line attribute mark delimited.",
            "detail": "SENTENCE({expression})"
         },
         {
            "key": "Seq",
            "icon": 3,
            "index": 327,
            "documentation": "The SEQ function returns numeric ASCII value of a character.\r\nexpression may evaluate to any data type.\r\nHowever the SEQ function will convert the expression to a string and operate on the first character of that string.\r\nThe function operates on any character in the integer range 0 to 255",
            "detail": "SEQ(expression)"
         },
         {
            "key": "Seqs",
            "icon": 3,
            "index": 328,
            "documentation": "The SEQS function converts a dynamic array of ASCII characters to their numeric string equivalents.\r\ndynamic.array specifies the ASCII characters to be converted.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf any element of dynamic.array is null, it returns null for that element.\r\nIf the subroutine syntax is used, the resulting dynamic array is returned as return.array.\r\nBy using the function to convert a character outside its range results in a run-time message, and the return of an empty string.",
            "detail": "SEQS(dynamic.array)"
         },
         {
            "key": "Sin",
            "icon": 3,
            "index": 329,
            "documentation": "The SIN function returns the mathematical sine value of a numeric expression.\r\nexpression should evaluate to a numeric value and is interpreted as a number of degrees between 0 and 360.\r\nThe function will calculate the sine of the angle specified by the expression as accurately as the host system will allow.\r\nIt will then truncate the value according to the PRECISION of the program.",
            "detail": "SIN(expression)"
         },
         {
            "key": "Sleep",
            "icon": 3,
            "index": 330,
            "documentation": "Allows the program to pause execution for a specified time period.\r\nSee also MSLEEP to sleep for a specified number of milliseconds.\r\nexpression may evaluate to one of two forms:\r\n* Numeric in which case the statement will sleep for the specified number of seconds or fractions of a second.\r\n* 'nn:nn{:nn}' in which case the statement will sleep until the time specified.\r\nIf expression is not supplied then a default time period of 1 second is assumed.",
            "detail": "SLEEP {expression}"
         },
         {
            "key": "Smul",
            "icon": 3,
            "index": 331,
            "documentation": "The SMUL function performs string multiplication of two base 10 string numbers.\r\nexpr1 and expr2 are strings consisting of numeric characters, with either optionally including a decimal part.\r\nThe SMUL function can be used with numbers that may exceed a valid range with standard arithmetic operators.\r\nThe  PRECISION declaration does not affect the value returned by he function.",
            "detail": "SMUL(expr1, expr2)"
         },
         {
            "key": "Sort",
            "icon": 3,
            "index": 332,
            "documentation": "The SORT function sorts all elements of a dynamic array in ascending left-justified order.\r\nexpression may evaluate to any data type but will only be useful if it evaluates to a dynamic array.\r\nThe dynamic array can contain any number and combination of system delimiters.\r\nThe SORT() function will return an attribute delimited array of the sorted elements.\r\nNote that all system delimiters in expression will be converted to an attribute mark '0xFE' in the sorted result.\r\nThe SORT function is implemented using the quick sort algorithm, which sorts in situ and is very fast.",
            "detail": "SORT(expression)"
         },
         {
            "key": "Soundex",
            "icon": 3,
            "index": 333,
            "documentation": "The SOUNDEX function allows phonetic conversions of strings.\r\nexpression may evaluate to any data type, but the function will only return meaningful results for English words.\r\nThe phonetic equivalent of a string is calculated as the first alphabetic character in the string followed by a 1 to 3 digit representation of the rest of the word.",
            "detail": "SOUNDEX(expression)"
         },
         {
            "key": "Space",
            "icon": 3,
            "index": 334,
            "documentation": "The SPACE function is a convenient way to generate a specific number of ASCII space characters.\r\nexpression should evaluate to a positive integer value.\r\nThe SPACE function will return the specified number of ASCII space characters and is useful for padding strings.\r\nIt should not be used to position output on the terminal screen however as this is inefficient and should be accomplished using the @( ) function.",
            "detail": "SPACE(expression)"
         },
         {
            "key": "Spaces",
            "icon": 3,
            "index": 335,
            "documentation": "The SPACES function returns a dynamic array with elements composed of blank spaces.\r\ndynamic.array specifies the number of spaces in each element.\r\nIf dynamic.array or any element of dynamic.array evaluates to null, the SPACES function will enter the debugger.",
            "detail": "SPACES(dynamic.array)"
         },
         {
            "key": "Splice",
            "icon": 3,
            "index": 336,
            "documentation": "The SPLICE function returns a dynamic array of the element by element concatenation of two dynamic arrays.\r\nEach element of array1 is concatenated with expression and with the corresponding element of array2.\r\nThe result is returned in the corresponding element of a new dynamic array.\r\nIf an element of one dynamic array has no corresponding element in the other dynamic array, the element is returned properly concatenated with expression.\r\nIf either element of a corresponding pair is null, null is returned for that element.\r\nIf expression evaluates to null, null is returned for the entire dynamic array.",
            "detail": "SPLICE(array1, expression, array2)"
         },
         {
            "key": "Spooler",
            "icon": 3,
            "index": 337,
            "documentation": "The SPOOLER function returns information from the jBASE spooler.\r\nn specifies the information that is returned\r\nPort limits the information returned to the specified port\r\nUser limits the information returned to the specified user.",
            "detail": "SPOOLER(n{, Port|User})"
         },
         {
            "key": "Sqrt",
            "icon": 3,
            "index": 338,
            "documentation": "The SQRT function returns the mathematical square root of a value.\r\nThe expression should evaluate to a positive numeric value as the authors did not want to introduce a complex number type within the language.\r\nNegative values will cause a math error.\r\nThe function calculates the result at the highest precision available and then truncates the answer to the required PRECISION.",
            "detail": "SQRT(expression)"
         },
         {
            "key": "Squote",
            "icon": 3,
            "index": 339,
            "documentation": "The function will put single quotation mark at the beginning and end of a string.\r\nexpression may be any expression that is valid in the JBC language.\r\nThe SQUOTE function will enclose the value in single quotation marks.",
            "detail": "SQUOTE(Expression)"
         },
         {
            "key": "Sselect",
            "icon": 14,
            "index": 340,
            "documentation": "The SSELECT statement allows the creation of numbered select list of record IDs in sorted order from a jBASE file or from a dynamic array.\r\nA select list of record IDs from a dynamic array is not in sorted order.\r\nvariable can specify a dynamic array or a file variable.\r\nIf it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254). \r\nIf variable specifies a file variable, the file variable must have previously been opened.\r\nIf variable is not specified, the default file is assumed.\r\nIf the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message.\r\nThe TO clause specifies the select list that is to be used.\r\nlist.number is an integer from 0 through 10.\r\nIf no list.number is specified, select list 0 is used.\r\nThe record IDs of all the records in the file forms the list.\r\nThe record IDs are listed in ascending order\r\nEach record ID is one entry in the list.\r\nThe ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
            "detail": "SSELECT [variable] [TO list.number] [ON ERROR statements]"
         },
         {
            "key": "Sselectn",
            "icon": 14,
            "index": 341,
            "documentation": "The SSELECTN statement allows the creation of numbered select list of record IDs from a jBASE file or dynamic array and stores the select list in a numbered list variable.\r\nA select list of record IDs from a dynamic array is not in sorted order.\r\nvariable can specify a dynamic array or a file variable.\r\nIf it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254). \r\nIf variable specifies a file variable, the file variable must have previously been opened.\r\nIf variable is not specified, the default file is assumed.\r\nIf the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message.\r\nThe TO clause specifies the select list number that is to be used, weher list.number is an integer from 0 through 10.\r\nIf no list.number is specified, select list 0 is used.\r\nThe record IDs of all the records in the file forms the list.\r\nThe record IDs are listed in ascending order\r\nEach record ID is one entry in the list.\r\nThe ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
            "detail": "SSELECTN [variable] [TO list.number] [ON ERROR statements]"
         },
         {
            "key": "Sselectv",
            "icon": 14,
            "index": 342,
            "documentation": "The SSELECTV statement allows the creation of select list of record IDs from a jBASE file or dynamic array and stores the select list in a named list variable.\r\nA select list of record IDs from a dynamic array is not in sorted order.\r\nvariable can specify a dynamic array or a file variable.\r\nIf it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254). \r\nIf variable specifies a file variable, the file variable must have previously been opened.\r\nIf variable is not specified, the default file is assumed.\r\nIf the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message.\r\nThe TO clause specifies the select list that is to be used.\r\nlist.variable is an expression that evaluates to a valid variable name.\r\nThe record IDs of all the records in the file forms the list.\r\nThe record IDs are listed in ascending order\r\nEach record ID is one entry in the list.\r\nThe ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
            "detail": "SSELECTV [variable] TO list.variable [ON ERROR statements]"
         },
         {
            "key": "Ssub",
            "icon": 3,
            "index": 343,
            "documentation": "The SSUB function performs string subtraction of two base 10 string numbers.\r\nexpr1 and expr2 are strings consisting of numeric characters, optionally including a decimal part.\r\nThe SSUB function can be used with numbers that may exceed a valid range with standard arithmetic operators.\r\nThe  PRECISION declaration has no effect on the value returned by the function.",
            "detail": "SSUB(expr1, expr2)"
         },
         {
            "key": "Status",
            "icon": 3,
            "index": 344,
            "documentation": "Use the STATUS function after an OPENPATH statement to find the cause of a file open failure (that is, for a statement in which the ELSE clause is used).",
            "detail": "STATUS()"
         },
         {
            "key": "Status",
            "icon": 14,
            "index": 345,
            "documentation": "Use the STATUS statement to determine the status of an open file.\r\nvariable specifies an open file.\r\nIf variable evaluates to the null value, the STATUS statement fails and the program terminates with a run-time error message.\r\nIf the STATUS is assigned to an array, the THEN statements are executed and the ELSE statements are ignored.\r\nIf no THEN statements are present, program execution continues with the next statement.\r\nIf the attempt to assign the array fails, the ELSE statements are executed; any THEN statements are ignored.",
            "detail": "STATUS array FROM variable THEN statements ELSE statements|ELSE statements"
         },
         {
            "key": "Stop",
            "icon": 3,
            "index": 346,
            "documentation": "The STOP statement is virtually identical in function to the ABORT statement except that a calling jCL program will not be terminated.\r\nThe optional message.number provided with the statement must be a numeric value, which corresponds to a record key in the jBASE error message file.\r\nA single expression or a list of expressions may follow the message.number.\r\nWhere more than one expression is listed, they must be delimited by use of the comma character.\r\nThe expression(s) correspond to the parameters that need to be passed to the error file record to display it.\r\nThe optional message.number and expression(s) given with the command are parameters or resultants provided as variables, literal strings, expressions, or functions.",
            "detail": "STOP {message.number{, expression ...}}"
         },
         {
            "key": "Stope",
            "icon": 3,
            "index": 347,
            "documentation": "The STOPE statement simply uses a message in the jbcmessages file whose item id is the first 'Expression', so in fact it operates exactly the same as STOP.",
            "detail": "STOPE {expression{, expression ...}}"
         },
         {
            "key": "Stopm",
            "icon": 3,
            "index": 348,
            "documentation": "The STOPM statement uses the STOPM item in the jBASE error message file $JBCRELEASEDIR/jbcmessages.",
            "detail": "STOPM {expression{, expression ...}}"
         },
         {
            "key": "Str",
            "icon": 3,
            "index": 349,
            "documentation": "The STR function allows the duplication of a string a number of times.\r\nexpression1 will evaluate to the string to duplicate and may be of any length.\r\nexpression2 should evaluate to a numeric integer, which specifies the number of times the string will be duplicated.",
            "detail": "STR(expression1, expression2)"
         },
         {
            "key": "Strs",
            "icon": 3,
            "index": 350,
            "documentation": "The STRS function produces a dynamic array containing the specified number of repetitions of each element of a dynamic array.\r\ndynamic.array is an expression that evaluates to the strings to be generated.\r\nrepeat is an expression that evaluates to the number of times the elements are to be repeated.\r\nIf it does not evaluate to a value that can be truncated to a positive integer, an empty string is returned for dynamic.array.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf any element of dynamic.array is null, null is returned for that element.\r\nIf repeat evaluates to null, the function fails and the program enters the debugger.",
            "detail": "STRS(dynamic.array, repeat)"
         },
         {
            "key": "Subroutine",
            "icon": 14,
            "index": 351,
            "documentation": "The SUBROUTINE statement is used at the start of any program that will be called externally by the CALL statement. It also declares any parameters to the compiler.\r\nName is the identifier by which the subroutine will be known to the compilation process.\r\nIt should always be present as this name (not the source file name), will be used to call it by.\r\nHowever, if the name is left out, the compiler will name subroutine as the source file name (without suffixes).\r\nDefault naming is not encouraged as it can cause problems if source files are renamed.\r\nEach comma separated variable in the optional parenthesized list is used to identify parameters to the compiler.\r\nThese variables will be assigned the values passed to the subroutine by a CALL statement.\r\nThe SUBROUTINE statement must be the first code line in a subroutine.",
            "detail": "SUB{ROUTINE} Name {({MAT} variable{,{MAT} variable...})}"
         },
         {
            "key": "Subs",
            "icon": 3,
            "index": 352,
            "documentation": "The SUBS function returns a dynamic array, the content of which is derived by subtracting each element of the second dynamic array argument from the corresponding element of the first dynamic array argument.\r\nDynArr1 and DynArr2 represent dynamic arrays.\r\nNull elements of argument arrays are treated as zero.\r\nOtherwise, a non-numeric element in an argument array will cause a run-time error.",
            "detail": "SUBS(DynArr1, DynArr2)"
         },
         {
            "key": "Substrings",
            "icon": 3,
            "index": 353,
            "documentation": "The SUBSTRINGS function returns a dynamic array of elements which are sub-strings of the corresponding elements in a supplied dynamic array.\r\nDynArr should evaluate to a dynamic array.\r\nStart specifies the position from which characters are extracted from each array element.\r\nIt should evaluate to an integer greater than zero.\r\nLength specifies the number of characters to extract from each dynamic array element.\r\nIf the length specified exceeds the number of characters remaining in an array element, then all characters from the Start position are extracted.",
            "detail": "SUBSTRINGS(DynArr, Start, Length)"
         },
         {
            "key": "Sum",
            "icon": 3,
            "index": 354,
            "documentation": "The SUM function sums numeric elements in a dynamic array.\r\nexpr is a dynamic array.\r\nNon-numeric sub-values, values and attributes are ignored.",
            "detail": "SUM(DynaArr)"
         },
         {
            "key": "Swap",
            "icon": 3,
            "index": 355,
            "documentation": "The SWAP function operates on a variable and replaces all occurrences of one string with another.\r\nexpression1 may evaluate to any result and is the string of characters that will be replaced.\r\nexpression2 may also evaluate to any result and is the string of characters that will replace expression1.\r\nThe variable may be any previously assigned variable in the program.\r\nEither string can be of any length and is not required to be the same length.\r\nThis function is provided for compatibility with older systems.\r\nSee also the CHANGE() function.",
            "detail": "SWAP( variable, expression1, expression2 )"
         },
         {
            "key": "System",
            "icon": 3,
            "index": 356,
            "documentation": "The SYSTEM functions return information about the current user and processes",
            "detail": "SYSTEM(integer)"
         },
         {
            "key": "Tan",
            "icon": 3,
            "index": 357,
            "documentation": "The TAN function returns the mathematical tangent of an angle.\r\nexpression should evaluate to a numeric type.\r\nThe function calculates the result at the highest precision available on the host system.\r\nThe result is truncated to the current PRECISION after calculation.",
            "detail": "TAN(expression)"
         },
         {
            "key": "Time",
            "icon": 3,
            "index": 358,
            "documentation": "The TIME() function returns the current system time in internal format (as the number of seconds past midnight).",
            "detail": "TIME()"
         },
         {
            "key": "Timedate",
            "icon": 3,
            "index": 359,
            "documentation": "The TIMEDATE() function returns the current time and date as a printable string.\r\nThe function returns a string of the form: hh:mm:ss dd mmm yyyy , or in the appropriate format for the international date setting on the system.",
            "detail": "TIMEDATE()"
         },
         {
            "key": "Timediff",
            "icon": 3,
            "index": 360,
            "documentation": "The TIMEDIFF function returns the interval between two timestamp values as a dynamic array.\r\nThe function returns the interval between two timestamp values by subtracting the value of Timestamp2 from Timestamp1.\r\nThe interval is returned as an attribute delimited array of the time difference.\r\nThe Mask is an integer from 0 to 7.",
            "detail": "TIMEDIFF(Timestamp1, Timestamp2,Mask)"
         },
         {
            "key": "Timeout",
            "icon": 14,
            "index": 361,
            "documentation": "The TIMEOUT statement terminates a READBLK or READSEQ statement.\r\nfile.variable specifies a file opened for sequential access.\r\ntime is an expression that evaluates to the number of seconds the program should wait before terminating the READSEQ statement.\r\nTIMEOUT causes subsequent READSEQ and READBLK statements to terminate and execute ELSE statements if the number of seconds specified by time elapses while waiting for data.\r\nIf either file.variable or time evaluates to null, the TIMEOUT statement fails and the program enters the debugger.",
            "detail": "TIMEOUT file.variable, time"
         },
         {
            "key": "Timestamp",
            "icon": 3,
            "index": 362,
            "documentation": "The TIMESTAMP function returns a UTC timestamp value as decimal seconds.\r\nThe TIMESTAMP function returns a Universal Coordinated Time (UTC) value as decimal seconds, i.e. seconds with tenths and hundredths specified after the decimal point.\r\nThe value is returned as a variable with as many decimal places as the current precision allows.\r\nHowever, successive calls may return the same value a number of times before the operating system updates the underlying timer.",
            "detail": "TIMESTAMP()"
         },
         {
            "key": "Trans",
            "icon": 3,
            "index": 363,
            "documentation": "The TRANS function will return the data value of a field, given the name of the file, the record key, the field number, and an action code.\r\nDICT is the literal string to be placed before the file name in the event it is desired to open the dictionary portion of the file, rather than the data portion.\r\nfilename is a string containing the name of the file to be accessed.  Note that it is the actual name of the file, and not a file unit variable.\r\nThis function requires the file name, regardless of whether or not the file has been opened to a file unit variable.\r\nkey  is an expression that evaluates to the record key, or item ID, of the record from which data is to be accessed.\r\nfield#  is the field number to be retrieved from the record.\r\naction.code  a literal which indicates what should happen if the field is null, or the if record is not found.",
            "detail": "TRANS ([DICT] filename, key, field#, action.code)"
         },
         {
            "key": "Transabort",
            "icon": 14,
            "index": 364,
            "documentation": "This statement is used to abort the current transaction and reverse any updates to the database.\r\nabort-text specifies an optional text string to save in the transaction abort record.\r\nA THEN or ELSE (or both) statement is required.\r\nThe THEN clause will be be executed if the transaction is successfully aborted.\r\nThe ELSE clause will be executed if the transaction abort fails for any reason.",
            "detail": "TRANSABORT {abort-text} [THEN statement | ELSE statement]"
         },
         {
            "key": "Transend",
            "icon": 14,
            "index": 365,
            "documentation": "This statement is used to mark the end of a successfully completed transaction.\r\nend-text specifies an optional text string to save with the transaction end record.\r\nA THEN or ELSE (or both) statement is required.\r\nThe THEN clause will be executed if the transaction is successfully ended.\r\nThe ELSE clause will be executed if the transaction end fails for any reason.",
            "detail": "TRANSEND {end-text} [THEN statement | ELSE statement]"
         },
         {
            "key": "Transquery",
            "icon": 14,
            "index": 366,
            "documentation": "This function is used to detect whether or not a transaction is active on the current process.\r\nTRANSQUERY will return 1 (true) if the process is within a transaction boundary, and 0 (false) if it is not.\r\nIn other words, TRANSQUERY will return true if the TRANSTART statement has been issued but a TRANSEND or TRANSABORT statement has not yet been processed.",
            "detail": "ROLLBACK"
         },
         {
            "key": "Transtart",
            "icon": 14,
            "index": 367,
            "documentation": "In transaction processing, this statement is used to mark the beginning of a transaction.\r\nSYNC is an option to force the updates to be flushed at transaction end or abort.\r\nstart-text specifies an optional text string to save with the transaction start record.\r\nA THEN or ELSE (or both) statement is required.\r\nThe THEN clause will be executed if the transaction is successfully started.\r\nThe ELSE clause will be executed if the transaction start fails for any reason.",
            "detail": "TRANSTART {SYNC}{start-text} [THEN statement | ELSE statement]"
         },
         {
            "key": "Trim",
            "icon": 3,
            "index": 368,
            "documentation": "The TRIM statement allows characters to be removed from a string in a number of ways.\r\nexpression1 specifies the string from which to trim characters.\r\nexpression2 may optionally specify the character to remove from the string. If not specified then the space character is assumed.\r\nexpression3 evaluates to a single character specifies the type of trim to perform.",
            "detail": "TRIM(expression1 {, expression2{, expression3}})"
         },
         {
            "key": "Trimb",
            "icon": 3,
            "index": 369,
            "documentation": "The TRIMB() function is equivalent to TRIM(expression, \" \", \"T\")",
            "detail": "TRIMB(expression)"
         },
         {
            "key": "Trimbs",
            "icon": 3,
            "index": 370,
            "documentation": "The TRIMBS function removes all trailing spaces and tabs from each element of a dynamic array.\r\nTRIMBS removes all trailing spaces and tabs from each element and reduces multiple occurrences of spaces and tabs to a single space or tab.\r\nIf dynamic.array evaluates to null, null is returned.\r\nIf any element of dynamic.array is null, null is returned for that value.",
            "detail": "TRIMBS(dynamic.array)"
         },
         {
            "key": "Trimf",
            "icon": 3,
            "index": 371,
            "documentation": "The TRIMF() function is equivalent to TRIM(expression, \" \", \"L\")",
            "detail": "TRIMF(expression)"
         },
         {
            "key": "Trimfs",
            "icon": 3,
            "index": 372,
            "documentation": "The TRIMFS function removes all leading, trailing and redundant spaces and tabs from each element of a dynamic array.\r\nTRIMFS removes all leading and trailing spaces and tabs from each element and reduces multiple occurrences of spaces and tabs to a single space or tab.\r\nIf dynamic.array evaluates to null, null is returned.\r\nIf any element of dynamic.array is null, null is returned for that value.",
            "detail": "TRIMFS(dynamic.array)"
         },
         {
            "key": "Trims",
            "icon": 3,
            "index": 373,
            "documentation": "The TRIMS function removes redundant spaces and tabs from each element of a dynamic array.\r\nTdynamic.array specifies the elements to be scanned.\r\nIf dynamic.array evaluates to null, it returns null.\r\nIf any element of dynamic.array is null, it returns null for that element.\r\nIf the subroutine syntax is used, the resulting dynamic array is returned as return.array. ",
            "detail": "TRIMS(dynamic.array)"
         },
         {
            "key": "Unassigned",
            "icon": 3,
            "index": 374,
            "documentation": "The UNASSIGNED function allows a program to determine whether a variable has been assigned a value.\r\nvariable is the name of variable used elsewhere in the program.\r\nThe function returns Boolean TRUE if variable has not yet been assigned a value and Boolean FALSE if variable has already been assigned a value.",
            "detail": "UNASSIGNED(variable)"
         },
         {
            "key": "Uniquekey",
            "icon": 3,
            "index": 375,
            "documentation": "The UNIQUEKEY function returns a unique 16-byte character key.\r\nThe UNIQUEKEY() function will generate a unique 16-byte character key on each call to the function.\r\nThe key contains characters from the set A-Z a-z 0-9 ^ and _ (base64). Based on the current UTC time and the process number, the key is unique on a single computer system providing that the system clock is not turned back.",
            "detail": "UNIQUEKEY()"
         },
         {
            "key": "Unlock",
            "icon": 14,
            "index": 376,
            "documentation": "The UNLOCK statement releases a previously LOCKed execution lock.\r\nIf expression is specified it should evaluate to the number of a held execution lock, which will then be released.\r\nIf expression is omitted then all execution locks held by the current program will be released.\r\nNo action is taken if the program attempts to release an execution lock that it had not taken.",
            "detail": "UNLOCK {expression}"
         },
         {
            "key": "Until",
            "icon": 14,
            "index": 377,
            "documentation": "The UNTIL statement terminates a FOR or LOOP loop when the specified expression is true. The optional DO is required in a LOOP",
            "detail": "UNTIL expr {DO}"
         },
         {
            "key": "Upcase",
            "icon": 3,
            "index": 378,
            "documentation": "UPCASE converts all lowercase characters in an expression to uppercase characters.\r\nexpression in a string containing alphabetic characters.",
            "detail": "UPCASE(expression)"
         },
         {
            "key": "Utf8",
            "icon": 3,
            "index": 379,
            "documentation": "The UTF8 function converts a latin1 or binary string into the UTF-8 equivalent byte sequence.\r\nThe expression is expected to be a binary/latin1code page string.\r\nThe function converts the binary string into a UTF-8 encoded byte sequence, used to represent the Unicode values for each byte in the expression.\r\nThis function is useful for converting binary or latin1 code page data into internal format when in International Mode",
            "detail": "UTF8(expression)"
         },
         {
            "key": "Wake",
            "icon": 14,
            "index": 380,
            "documentation": "The WAKE statement is used to wake a suspended process which has executed a PAUSE statement.\r\nPortNumber is a reference to the target port to be awoken.\r\nThe WAKE statement has no effect on processes which do not execute the PAUSE statement.",
            "detail": "WAKE PortNumber"
         },
         {
            "key": "Weof",
            "icon": 14,
            "index": 381,
            "documentation": "The WEOF statement allows the program to write an EOF mark on an attached tape device.\r\nexpression specifies the device channel to use, which should evaluate to a numeric integer argument in the range 0-9.\r\nDefault value is 0.\r\nf the WEOF fails then the statements associated with any ELSE clause will be executed.\r\nSYSTEM(0) will return a reason code for the failure.\r\nA \"tape\" not only refers to magnetic tape devices but to any device that has been described to jBASE.\r\nIf no tape device has been assigned to the channel specified then the jBASE debugger is entered with an appropriate message.",
            "detail": "WEOF {ON expression}"
         },
         {
            "key": "Weofseq",
            "icon": 14,
            "index": 382,
            "documentation": "Write end of file on file opened for sequential access.\r\nFileVar specifies the file descriptor of the file opened for sequential access.\r\nStatements are conditional jBC statements\r\nWEOFSEQ forces the file to be truncated at the current file pointer. Nothing is actually 'written' to the sequential file.",
            "detail": "WEOFSEQ FileVar { THEN | ELSE Statements}"
         },
         {
            "key": "While",
            "icon": 14,
            "index": 383,
            "documentation": "The WHILE statement terminates a FOR or LOOP loop when the specified expression is true. The optional DO is required in a LOOP.",
            "detail": "WHILE expr {DO}"
         },
         {
            "key": "Write",
            "icon": 14,
            "index": 384,
            "documentation": "The WRITE statement allows a program to write a record into a previously opened file.\r\nvariable1 is the identifier containing the record to write.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\rr\nThe expression should evaluate to a valid record key for the file.\r\nIf the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.\r\nIf a lock was being held on the record by this process it will be released by the WRITE.\r\nIf a lock should be retained on a record, it should be done so explicitly with the WRITEU statement.\r\nA 'WRITE' of a null item-id to a directory will take the 'ON ERROR' clause, if it exists.",
            "detail": "WRITE variable1 ON|TO { variable2,} expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Writeblk",
            "icon": 14,
            "index": 385,
            "documentation": "The WRITEBLK statement writes a block of data to a file opened for sequential processing.\r\nEach WRITEBLK statement writes the value of expression starting at the current position in the file.\r\nThe current position is incremented to beyond the last byte written.\r\nWRITEBLK does not add a new line at the end of the data.\r\nfile.variable specifies a file opened for sequential processing.\r\nThe value of expression is written to the file, and the THEN statements are executed.\r\nIf no THEN statements are specified, program execution continues with the next statement.\r\nIf the file is neither accessible or does not exist, it executes the ELSE statements; and ignores any THEN statements.\r\nIf either expression or file.variable evaluates to null, the WRITEBLK statement fails and the program enters the debugger with a run-time error message.",
            "detail": "WRITEBLK expression ON file.variable {THEN statements [ELSE statements]|ELSE statements}"
         },
         {
            "key": "Writelist",
            "icon": 14,
            "index": 386,
            "documentation": "WRITELIST allows the program to store a list held in a jBC variable to the global list file.\r\nvariable is the variable in which the list is held.\r\nexpression should evaluate to the required list name.\r\nIf expression is null, the list will be written to the default external list.\r\nIf the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.",
            "detail": "WRITELIST variable ON|TO expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Writeseq",
            "icon": 14,
            "index": 387,
            "documentation": "Write to a file opened for sequential access.\r\nVariable specifies the variable to contain next record from sequential file.\r\nFileVar specifies the file descriptor of the file opened for sequential access.\r\nStatements conditional jBC statements.\r\nEach WRITESEQ writes the data on a line of the sequentially opened file.\r\nEach line of data is suffixed with a new line character.\r\nAfter each WRITESEQ the file pointer moves forward to the end of line.\r\nThe APPEND option forces each WRITESEQ to advance to the end of the file before writing the next data line.",
            "detail": "WRITESEQ Expression {APPEND} ON|TO FileVar THEN | ELSE statements"
         },
         {
            "key": "Writeseqf",
            "icon": 14,
            "index": 388,
            "documentation": "Write to a file opened for sequential access and force each data line to be flushed to the file when it is written.\r\nVariable specifies the variable to contain next record from sequential file.\r\nFileVar specifies the file descriptor of the file opened for sequential access.\r\nStatements conditional jBC statements.\r\nEach WRITESEQ writes the data on a line of the sequentially opened file.\r\nEach line of data is suffixed with a new line character.\r\nAfter each WRITESEQ the file pointer moves forward to the end of line.\r\nThe WRITESEQF statement forces each data line to be flushed to the file when it is written.\r\nThe APPEND option forces each WRITESEQ to advance to the end of the file before writing the next data line.",
            "detail": "WRITESEQF Expression {APPEND} ON|TO FileVar THEN | ELSE statements"
         },
         {
            "key": "Writet",
            "icon": 14,
            "index": 389,
            "documentation": "The WRITET statement enables data to be written to a range of tape devices between 0-9.\r\nvariable holds the data for writing to the tape device.\r\nexpression should evaluate to an integer value in the range 0-9 and specifies which tape channel to read data from.\r\nIf the ON clause is not specified the WRITET will assume channel 0.\r\nIf the WRITET fails then the statements associated with any ELSE clause will be executed.\r\nSYSTEM(0) will return the reason code for the failure.\r\nA \"tape\" not only refers to magnetic tape devices but also any device that has been described to jBASE.\r\nIf no tape device has been assigned to the channel specified then the jBASE debugger is entered with an appropriate message.",
            "detail": "WRITET variable {ON|TO expression} THEN|ELSE statements"
         },
         {
            "key": "Writeu",
            "icon": 14,
            "index": 390,
            "documentation": "The WRITEU statement allows a program to write a record into a previously opened file. An existing record lock will be preserved.\r\nvariable1 is the identifier holding the record to be written.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nThe expression should evaluate to a valid record key for the file.\r\nIf the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.\r\nIf the statement fails to write the record then any statements associated with the ON ERROR clause are executed.\r\nThe lock maintained by the WRITEU statement will be released by any of the following events:\r\n* the record is written to by the same program with WRITE, WRITEV or MATWRITE statements.\r\n* the record lock is released explicitly using the RELEASEstatement.\r\n* the program stops normally or abnormally.",
            "detail": "WRITEU variable1 ON|TO { variable2,} expression {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Writev",
            "icon": 14,
            "index": 391,
            "documentation": "The WRITEV statement allows a program to write a specific field of a record in a previously opened file.\r\nvariable1 is the identifier holding the record to be written.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nexpression1 should evaluate to a valid record key for the file.\r\nexpression2 should evaluate to a positive integer number.\r\nIf the number is greater than the number of fields in the record, null fields will be added to variable1.\r\nIf expression2 evaluates to a non-numeric argument, a run time error will be generated.\r\nIf the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.\r\nThe WRITEV statement will cause any lock held on the record by this program to be released.\r\nIf a lock on the record should be retained, that should be done so explicitly with the WRITEVU statement.",
            "detail": "WRITEV variable1 ON|TO {variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Writevu",
            "icon": 14,
            "index": 392,
            "documentation": "The WRITEVU statement allows a program to write a specific field on a record in a previously opened file.\r\nAn existing record lock will be preserved.\r\nvariable1 is the identifier holding the record to be written.\r\nvariable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement.\r\nIf variable2 is not specified then the default file is assumed.\r\nexpression1 should evaluate to a valid record key for the file.\r\nexpression2 should evaluate to a positive integer number.\r\nIf the number is greater than the number of fields in the record, null fields will be added to variable1.\r\nIf expression2 evaluates to a non-numeric argument, a run time error will be generated.\r\nIf the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.\r\nIf the statement fails to write the record then any statements associated with the ON ERROR clause are executed.\r\nThe lock taken by the WRITEVU statement will be released by any of the following events:\r\n* The record is written to by the same program with WRITE, WRITEV or MATWRITE statements.\r\n* The record lock is released explicitly using the RELEASE statement.\r\n* The program stops normally or abnormally.",
            "detail": "WRITEVU variable1 ON|TO { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements}"
         },
         {
            "key": "Writexml",
            "icon": 14,
            "index": 393,
            "documentation": "The WRITEXML statement writes a dynamic array to a hashed file in XML format, using a style sheet from the DICT.\r\nThe XML is transformed into a dynamic array before being written to the file.\r\nThe transformation takes place using the stylesheet in DICT->@WRITEXML.",
            "detail": "WRITEXML rec ON file,id ELSE STOP 201,id"
         },
         {
            "key": "Xlate",
            "icon": 3,
            "index": 394,
            "documentation": "The XLATE function will return the data value of a field, given the name of the file, the record key, the field number, and an action code.DICT is the literal string to be placed before the file name in the event it is desired to open the dictionary portion of the file, rather than the data portion.\r\nfilename is a string containing the name of the file to be accessed.  Note that it is the actual name of the file, and not a file unit variable.\r\nThis function requires the file name, regardless of whether or not the file has been opened to a file unit variable.\r\nkey  is an expression that evaluates to the record key, or item ID, of the record from which data is to be accessed.\r\nfield#  is the field number to be retrieved from the record.\r\naction.code  a literal which indicates what should happen if the field is null, or the if record is not found.\r\nXLATE is a synonym of the TRANS function.",
            "detail": "XLATE ([DICT] filename, key, field#, action.code)"
         },
         {
            "key": "Xmltodyn",
            "icon": 3,
            "index": 395,
            "documentation": "The XMLTODYN function converts an XML expression to a dynamic array, using an optional XSL to transform.\r\nArray = XMLTODYN(XML,XSL,result)\r\nIf result = 0 Array will contain a dynamic array built from the xml / xsl.\r\nIf result <> 0, Array will contain an error message.",
            "detail": "XMLTODYN(XML, XSL, result)"
         },
         {
            "key": "Xmltoxml",
            "icon": 3,
            "index": 396,
            "documentation": "The XMLTOXML function transforms an XML expression using an XSL.\r\nnewxml=XMLTOXML(XML, XSL, result)\r\nIf result = 0, newxml  will contain a transformed version of XML using XSL.\r\nIf result = 1, newxml will contain an error message.",
            "detail": "XMLTOXML(XML, XSL, result)"
         },
         {
            "key": "Xtd",
            "icon": 3,
            "index": 397,
            "documentation": "The XTD() function converts hexadecimal number into its decimal equivalent.\r\nexpression should evaluate to a valid hexadecimal string.\r\nThe conversion process will halt at the first character that is not a valid base 16 character in the set [0-9, A-F or a-f].",
            "detail": "XTD(expression)"
         },
         {
            "key": "$Option",
            "icon": 14,
            "index": 398,
            "documentation": "The $OPTION directive allows dynamic objects options/parameters to be specified.\r\nkeyword is currently one or more of the following:\r\n arrow|auto|case|debug|jabba|keywords|object|period|self|stats|tokens|trace|universe|uv|uvcase|warning|warnings\r\n, commas separated.",
            "detail": "$option keyword"
         }
      ]
   }
}